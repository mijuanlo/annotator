/* valaflowanalyzer.c generated by valac, the Vala compiler
 * generated from valaflowanalyzer.vala, do not modify */

/* valaflowanalyzer.vala
 *
 * Copyright (C) 2008-2010  Jürg Billeter
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * Author:
 * 	Jürg Billeter <j@bitron.ch>
 */

#include "vala.h"
#include <glib.h>
#include <valagee.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gobject/gvaluecollector.h>

#define VALA_FLOW_ANALYZER_TYPE_JUMP_TARGET (vala_flow_analyzer_jump_target_get_type ())
#define VALA_FLOW_ANALYZER_JUMP_TARGET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_FLOW_ANALYZER_TYPE_JUMP_TARGET, ValaFlowAnalyzerJumpTarget))
#define VALA_FLOW_ANALYZER_JUMP_TARGET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_FLOW_ANALYZER_TYPE_JUMP_TARGET, ValaFlowAnalyzerJumpTargetClass))
#define VALA_FLOW_ANALYZER_IS_JUMP_TARGET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_FLOW_ANALYZER_TYPE_JUMP_TARGET))
#define VALA_FLOW_ANALYZER_IS_JUMP_TARGET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_FLOW_ANALYZER_TYPE_JUMP_TARGET))
#define VALA_FLOW_ANALYZER_JUMP_TARGET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_FLOW_ANALYZER_TYPE_JUMP_TARGET, ValaFlowAnalyzerJumpTargetClass))

typedef struct _ValaFlowAnalyzerJumpTarget ValaFlowAnalyzerJumpTarget;
typedef struct _ValaFlowAnalyzerJumpTargetClass ValaFlowAnalyzerJumpTargetClass;
#define _vala_code_context_unref0(var) ((var == NULL) ? NULL : (var = (vala_code_context_unref (var), NULL)))
#define _vala_basic_block_unref0(var) ((var == NULL) ? NULL : (var = (vala_basic_block_unref (var), NULL)))
#define _vala_iterable_unref0(var) ((var == NULL) ? NULL : (var = (vala_iterable_unref (var), NULL)))
#define _vala_map_unref0(var) ((var == NULL) ? NULL : (var = (vala_map_unref (var), NULL)))
#define _vala_source_file_unref0(var) ((var == NULL) ? NULL : (var = (vala_source_file_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _vala_code_node_unref0(var) ((var == NULL) ? NULL : (var = (vala_code_node_unref (var), NULL)))
#define _vala_flow_analyzer_jump_target_unref0(var) ((var == NULL) ? NULL : (var = (vala_flow_analyzer_jump_target_unref (var), NULL)))
#define _vala_iterator_unref0(var) ((var == NULL) ? NULL : (var = (vala_iterator_unref (var), NULL)))
#define _vala_phi_function_unref0(var) ((var == NULL) ? NULL : (var = (vala_phi_function_unref (var), NULL)))
typedef struct _ValaFlowAnalyzerJumpTargetPrivate ValaFlowAnalyzerJumpTargetPrivate;
typedef struct _ValaFlowAnalyzerParamSpecJumpTarget ValaFlowAnalyzerParamSpecJumpTarget;

struct _ValaFlowAnalyzerPrivate {
	ValaCodeContext* context;
	ValaBasicBlock* current_block;
	gboolean unreachable_reported;
	ValaList* jump_stack;
	ValaSet* all_basic_blocks;
	ValaMap* var_map;
	ValaSet* used_vars;
	ValaMap* phi_functions;
};

struct _ValaFlowAnalyzerJumpTarget {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ValaFlowAnalyzerJumpTargetPrivate * priv;
};

struct _ValaFlowAnalyzerJumpTargetClass {
	GTypeClass parent_class;
	void (*finalize) (ValaFlowAnalyzerJumpTarget *self);
};

struct _ValaFlowAnalyzerJumpTargetPrivate {
	gboolean _is_break_target;
	gboolean _is_continue_target;
	gboolean _is_return_target;
	gboolean _is_exit_target;
	gboolean _is_error_target;
	ValaErrorDomain* _error_domain;
	ValaErrorCode* _error_code;
	ValaClass* _error_class;
	gboolean _is_finally_clause;
	ValaBasicBlock* _basic_block;
	ValaBasicBlock* _last_block;
	ValaCatchClause* _catch_clause;
};

struct _ValaFlowAnalyzerParamSpecJumpTarget {
	GParamSpec parent_instance;
};

static gint ValaFlowAnalyzer_private_offset;
static gpointer vala_flow_analyzer_parent_class = NULL;
static gint ValaFlowAnalyzerJumpTarget_private_offset;
static gpointer vala_flow_analyzer_jump_target_parent_class = NULL;

static gpointer vala_flow_analyzer_jump_target_ref (gpointer instance);
static void vala_flow_analyzer_jump_target_unref (gpointer instance);
static GParamSpec* vala_flow_analyzer_param_spec_jump_target (const gchar* name,
                                                       const gchar* nick,
                                                       const gchar* blurb,
                                                       GType object_type,
                                                       GParamFlags flags) G_GNUC_UNUSED;
static void vala_flow_analyzer_value_set_jump_target (GValue* value,
                                               gpointer v_object) G_GNUC_UNUSED;
static void vala_flow_analyzer_value_take_jump_target (GValue* value,
                                                gpointer v_object) G_GNUC_UNUSED;
static gpointer vala_flow_analyzer_value_get_jump_target (const GValue* value) G_GNUC_UNUSED;
static GType vala_flow_analyzer_jump_target_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static void vala_flow_analyzer_real_visit_source_file (ValaCodeVisitor* base,
                                                ValaSourceFile* source_file);
static void vala_flow_analyzer_real_visit_class (ValaCodeVisitor* base,
                                          ValaClass* cl);
static void vala_flow_analyzer_real_visit_struct (ValaCodeVisitor* base,
                                           ValaStruct* st);
static void vala_flow_analyzer_real_visit_interface (ValaCodeVisitor* base,
                                              ValaInterface* iface);
static void vala_flow_analyzer_real_visit_enum (ValaCodeVisitor* base,
                                         ValaEnum* en);
static void vala_flow_analyzer_real_visit_error_domain (ValaCodeVisitor* base,
                                                 ValaErrorDomain* ed);
static void vala_flow_analyzer_real_visit_field (ValaCodeVisitor* base,
                                          ValaField* f);
static void vala_flow_analyzer_real_visit_lambda_expression (ValaCodeVisitor* base,
                                                      ValaLambdaExpression* le);
static void vala_flow_analyzer_mark_unreachable (ValaFlowAnalyzer* self);
static void vala_flow_analyzer_real_visit_method (ValaCodeVisitor* base,
                                           ValaMethod* m);
static void vala_flow_analyzer_visit_subroutine (ValaFlowAnalyzer* self,
                                          ValaSubroutine* m);
static void vala_flow_analyzer_real_visit_signal (ValaCodeVisitor* base,
                                           ValaSignal* sig);
static ValaFlowAnalyzerJumpTarget* vala_flow_analyzer_jump_target_new_return_target (ValaBasicBlock* basic_block);
static ValaFlowAnalyzerJumpTarget* vala_flow_analyzer_jump_target_construct_return_target (GType object_type,
                                                                                    ValaBasicBlock* basic_block);
static ValaFlowAnalyzerJumpTarget* vala_flow_analyzer_jump_target_new_exit_target (ValaBasicBlock* basic_block);
static ValaFlowAnalyzerJumpTarget* vala_flow_analyzer_jump_target_construct_exit_target (GType object_type,
                                                                                  ValaBasicBlock* basic_block);
static void vala_flow_analyzer_analyze_body (ValaFlowAnalyzer* self,
                                      ValaBasicBlock* entry_block);
static ValaList* vala_flow_analyzer_get_depth_first_list (ValaFlowAnalyzer* self,
                                                   ValaBasicBlock* entry_block);
static void vala_flow_analyzer_build_dominator_tree (ValaFlowAnalyzer* self,
                                              ValaList* block_list,
                                              ValaBasicBlock* entry_block);
static void vala_flow_analyzer_build_dominator_frontier (ValaFlowAnalyzer* self,
                                                  ValaList* block_list,
                                                  ValaBasicBlock* entry_block);
static void vala_flow_analyzer_insert_phi_functions (ValaFlowAnalyzer* self,
                                              ValaList* block_list,
                                              ValaBasicBlock* entry_block);
static void vala_flow_analyzer_check_variables (ValaFlowAnalyzer* self,
                                         ValaBasicBlock* entry_block);
static void vala_flow_analyzer_depth_first_traverse (ValaFlowAnalyzer* self,
                                              ValaBasicBlock* current,
                                              ValaList* list);
static ValaBasicBlock* vala_flow_analyzer_intersect (ValaFlowAnalyzer* self,
                                              ValaBasicBlock** idoms,
                                              gint idoms_length1,
                                              ValaBasicBlock* b1,
                                              ValaBasicBlock* b2);
static ValaMap* vala_flow_analyzer_get_assignment_map (ValaFlowAnalyzer* self,
                                                ValaList* block_list,
                                                ValaBasicBlock* entry_block);
static void vala_flow_analyzer_check_block_variables (ValaFlowAnalyzer* self,
                                               ValaBasicBlock* block);
static ValaVariable* vala_flow_analyzer_process_assignment (ValaFlowAnalyzer* self,
                                                     ValaMap* var_map,
                                                     ValaVariable* var_symbol);
static void vala_flow_analyzer_real_visit_creation_method (ValaCodeVisitor* base,
                                                    ValaCreationMethod* m);
static void vala_flow_analyzer_real_visit_property (ValaCodeVisitor* base,
                                             ValaProperty* prop);
static void vala_flow_analyzer_real_visit_property_accessor (ValaCodeVisitor* base,
                                                      ValaPropertyAccessor* acc);
static void vala_flow_analyzer_real_visit_block (ValaCodeVisitor* base,
                                          ValaBlock* b);
static void vala_flow_analyzer_real_visit_declaration_statement (ValaCodeVisitor* base,
                                                          ValaDeclarationStatement* stmt);
static gboolean vala_flow_analyzer_unreachable (ValaFlowAnalyzer* self,
                                         ValaCodeNode* node);
static void vala_flow_analyzer_handle_errors (ValaFlowAnalyzer* self,
                                       ValaCodeNode* node,
                                       gboolean always_fail);
static void vala_flow_analyzer_real_visit_local_variable (ValaCodeVisitor* base,
                                                   ValaLocalVariable* local);
static void vala_flow_analyzer_real_visit_expression_statement (ValaCodeVisitor* base,
                                                         ValaExpressionStatement* stmt);
static gboolean vala_flow_analyzer_always_true (ValaFlowAnalyzer* self,
                                         ValaExpression* condition);
static gboolean vala_flow_analyzer_always_false (ValaFlowAnalyzer* self,
                                          ValaExpression* condition);
static void vala_flow_analyzer_real_visit_if_statement (ValaCodeVisitor* base,
                                                 ValaIfStatement* stmt);
static void vala_flow_analyzer_real_visit_switch_statement (ValaCodeVisitor* base,
                                                     ValaSwitchStatement* stmt);
static ValaFlowAnalyzerJumpTarget* vala_flow_analyzer_jump_target_new_break_target (ValaBasicBlock* basic_block);
static ValaFlowAnalyzerJumpTarget* vala_flow_analyzer_jump_target_construct_break_target (GType object_type,
                                                                                   ValaBasicBlock* basic_block);
static void vala_flow_analyzer_real_visit_loop (ValaCodeVisitor* base,
                                         ValaLoop* stmt);
static ValaFlowAnalyzerJumpTarget* vala_flow_analyzer_jump_target_new_continue_target (ValaBasicBlock* basic_block);
static ValaFlowAnalyzerJumpTarget* vala_flow_analyzer_jump_target_construct_continue_target (GType object_type,
                                                                                      ValaBasicBlock* basic_block);
static void vala_flow_analyzer_real_visit_foreach_statement (ValaCodeVisitor* base,
                                                      ValaForeachStatement* stmt);
static void vala_flow_analyzer_real_visit_break_statement (ValaCodeVisitor* base,
                                                    ValaBreakStatement* stmt);
static gboolean vala_flow_analyzer_jump_target_get_is_break_target (ValaFlowAnalyzerJumpTarget* self);
static ValaBasicBlock* vala_flow_analyzer_jump_target_get_basic_block (ValaFlowAnalyzerJumpTarget* self);
static gboolean vala_flow_analyzer_jump_target_get_is_finally_clause (ValaFlowAnalyzerJumpTarget* self);
static ValaBasicBlock* vala_flow_analyzer_jump_target_get_last_block (ValaFlowAnalyzerJumpTarget* self);
static void vala_flow_analyzer_real_visit_continue_statement (ValaCodeVisitor* base,
                                                       ValaContinueStatement* stmt);
static gboolean vala_flow_analyzer_jump_target_get_is_continue_target (ValaFlowAnalyzerJumpTarget* self);
static void vala_flow_analyzer_real_visit_return_statement (ValaCodeVisitor* base,
                                                     ValaReturnStatement* stmt);
static gboolean vala_flow_analyzer_jump_target_get_is_return_target (ValaFlowAnalyzerJumpTarget* self);
static gboolean vala_flow_analyzer_jump_target_get_is_exit_target (ValaFlowAnalyzerJumpTarget* self);
static gboolean vala_flow_analyzer_jump_target_get_is_error_target (ValaFlowAnalyzerJumpTarget* self);
static ValaErrorDomain* vala_flow_analyzer_jump_target_get_error_domain (ValaFlowAnalyzerJumpTarget* self);
static ValaErrorCode* vala_flow_analyzer_jump_target_get_error_code (ValaFlowAnalyzerJumpTarget* self);
static ValaClass* vala_flow_analyzer_jump_target_get_error_class (ValaFlowAnalyzerJumpTarget* self);
static void vala_flow_analyzer_real_visit_yield_statement (ValaCodeVisitor* base,
                                                    ValaYieldStatement* stmt);
static void vala_flow_analyzer_real_visit_throw_statement (ValaCodeVisitor* base,
                                                    ValaThrowStatement* stmt);
static void vala_flow_analyzer_real_visit_try_statement (ValaCodeVisitor* base,
                                                  ValaTryStatement* stmt);
static ValaFlowAnalyzerJumpTarget* vala_flow_analyzer_jump_target_new_any_target (ValaBasicBlock* basic_block);
static ValaFlowAnalyzerJumpTarget* vala_flow_analyzer_jump_target_construct_any_target (GType object_type,
                                                                                 ValaBasicBlock* basic_block);
static ValaFlowAnalyzerJumpTarget* vala_flow_analyzer_jump_target_new_finally_clause (ValaBasicBlock* basic_block,
                                                                               ValaBasicBlock* last_block);
static ValaFlowAnalyzerJumpTarget* vala_flow_analyzer_jump_target_construct_finally_clause (GType object_type,
                                                                                     ValaBasicBlock* basic_block,
                                                                                     ValaBasicBlock* last_block);
static ValaFlowAnalyzerJumpTarget* vala_flow_analyzer_jump_target_new_error_target (ValaBasicBlock* basic_block,
                                                                             ValaCatchClause* catch_clause,
                                                                             ValaErrorDomain* error_domain,
                                                                             ValaErrorCode* error_code,
                                                                             ValaClass* error_class);
static ValaFlowAnalyzerJumpTarget* vala_flow_analyzer_jump_target_construct_error_target (GType object_type,
                                                                                   ValaBasicBlock* basic_block,
                                                                                   ValaCatchClause* catch_clause,
                                                                                   ValaErrorDomain* error_domain,
                                                                                   ValaErrorCode* error_code,
                                                                                   ValaClass* error_class);
static ValaCatchClause* vala_flow_analyzer_jump_target_get_catch_clause (ValaFlowAnalyzerJumpTarget* self);
static void vala_flow_analyzer_real_visit_lock_statement (ValaCodeVisitor* base,
                                                   ValaLockStatement* stmt);
static void vala_flow_analyzer_real_visit_unlock_statement (ValaCodeVisitor* base,
                                                     ValaUnlockStatement* stmt);
static void vala_flow_analyzer_real_visit_expression (ValaCodeVisitor* base,
                                               ValaExpression* expr);
static void vala_flow_analyzer_jump_target_set_is_break_target (ValaFlowAnalyzerJumpTarget* self,
                                                         gboolean value);
static void vala_flow_analyzer_jump_target_set_is_continue_target (ValaFlowAnalyzerJumpTarget* self,
                                                            gboolean value);
static void vala_flow_analyzer_jump_target_set_is_return_target (ValaFlowAnalyzerJumpTarget* self,
                                                          gboolean value);
static void vala_flow_analyzer_jump_target_set_is_exit_target (ValaFlowAnalyzerJumpTarget* self,
                                                        gboolean value);
static void vala_flow_analyzer_jump_target_set_is_error_target (ValaFlowAnalyzerJumpTarget* self,
                                                         gboolean value);
static void vala_flow_analyzer_jump_target_set_error_domain (ValaFlowAnalyzerJumpTarget* self,
                                                      ValaErrorDomain* value);
static void vala_flow_analyzer_jump_target_set_error_code (ValaFlowAnalyzerJumpTarget* self,
                                                    ValaErrorCode* value);
static void vala_flow_analyzer_jump_target_set_error_class (ValaFlowAnalyzerJumpTarget* self,
                                                     ValaClass* value);
static void vala_flow_analyzer_jump_target_set_is_finally_clause (ValaFlowAnalyzerJumpTarget* self,
                                                           gboolean value);
static void vala_flow_analyzer_jump_target_set_basic_block (ValaFlowAnalyzerJumpTarget* self,
                                                     ValaBasicBlock* value);
static void vala_flow_analyzer_jump_target_set_last_block (ValaFlowAnalyzerJumpTarget* self,
                                                    ValaBasicBlock* value);
static void vala_flow_analyzer_jump_target_set_catch_clause (ValaFlowAnalyzerJumpTarget* self,
                                                      ValaCatchClause* value);
static ValaFlowAnalyzerJumpTarget* vala_flow_analyzer_jump_target_new (void);
static ValaFlowAnalyzerJumpTarget* vala_flow_analyzer_jump_target_construct (GType object_type);
static void vala_flow_analyzer_jump_target_finalize (ValaFlowAnalyzerJumpTarget * obj);
static GType vala_flow_analyzer_jump_target_get_type_once (void);
static void vala_flow_analyzer_finalize (ValaCodeVisitor * obj);
static GType vala_flow_analyzer_get_type_once (void);
static void _vala_array_destroy (gpointer array,
                          gint array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gint array_length,
                       GDestroyNotify destroy_func);

static inline gpointer
vala_flow_analyzer_get_instance_private (ValaFlowAnalyzer* self)
{
	return G_STRUCT_MEMBER_P (self, ValaFlowAnalyzer_private_offset);
}

ValaFlowAnalyzer*
vala_flow_analyzer_construct (GType object_type)
{
	ValaFlowAnalyzer* self = NULL;
	self = (ValaFlowAnalyzer*) vala_code_visitor_construct (object_type);
	return self;
}

ValaFlowAnalyzer*
vala_flow_analyzer_new (void)
{
	return vala_flow_analyzer_construct (VALA_TYPE_FLOW_ANALYZER);
}

/**
 * Build control flow graph in the specified context.
 *
 * @param context a code context
 */
static gpointer
_vala_code_context_ref0 (gpointer self)
{
	return self ? vala_code_context_ref (self) : NULL;
}

static gpointer
_vala_iterable_ref0 (gpointer self)
{
	return self ? vala_iterable_ref (self) : NULL;
}

void
vala_flow_analyzer_analyze (ValaFlowAnalyzer* self,
                            ValaCodeContext* context)
{
	ValaCodeContext* _tmp0_;
	GHashFunc _tmp1_;
	GEqualFunc _tmp2_;
	ValaHashSet* _tmp3_;
	ValaList* source_files = NULL;
	ValaList* _tmp4_;
	ValaList* _tmp5_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (context != NULL);
	_tmp0_ = _vala_code_context_ref0 (context);
	_vala_code_context_unref0 (self->priv->context);
	self->priv->context = _tmp0_;
	_tmp1_ = g_direct_hash;
	_tmp2_ = g_direct_equal;
	_tmp3_ = vala_hash_set_new (VALA_TYPE_BASIC_BLOCK, (GBoxedCopyFunc) vala_basic_block_ref, (GDestroyNotify) vala_basic_block_unref, _tmp1_, _tmp2_);
	_vala_iterable_unref0 (self->priv->all_basic_blocks);
	self->priv->all_basic_blocks = (ValaSet*) _tmp3_;
	_tmp4_ = vala_code_context_get_source_files (context);
	_tmp5_ = _vala_iterable_ref0 (_tmp4_);
	source_files = _tmp5_;
	{
		ValaList* _file_list = NULL;
		ValaList* _tmp6_;
		ValaList* _tmp7_;
		gint _file_size = 0;
		ValaList* _tmp8_;
		gint _tmp9_;
		gint _tmp10_;
		gint _file_index = 0;
		_tmp6_ = source_files;
		_tmp7_ = _vala_iterable_ref0 (_tmp6_);
		_file_list = _tmp7_;
		_tmp8_ = _file_list;
		_tmp9_ = vala_collection_get_size ((ValaCollection*) _tmp8_);
		_tmp10_ = _tmp9_;
		_file_size = _tmp10_;
		_file_index = -1;
		while (TRUE) {
			gint _tmp11_;
			gint _tmp12_;
			ValaSourceFile* file = NULL;
			ValaList* _tmp13_;
			gpointer _tmp14_;
			ValaSourceFile* _tmp15_;
			_file_index = _file_index + 1;
			_tmp11_ = _file_index;
			_tmp12_ = _file_size;
			if (!(_tmp11_ < _tmp12_)) {
				break;
			}
			_tmp13_ = _file_list;
			_tmp14_ = vala_list_get (_tmp13_, _file_index);
			file = (ValaSourceFile*) _tmp14_;
			_tmp15_ = file;
			vala_source_file_accept (_tmp15_, (ValaCodeVisitor*) self);
			_vala_source_file_unref0 (file);
		}
		_vala_iterable_unref0 (_file_list);
	}
	_vala_iterable_unref0 (self->priv->all_basic_blocks);
	self->priv->all_basic_blocks = NULL;
	_vala_code_context_unref0 (self->priv->context);
	self->priv->context = NULL;
	_vala_iterable_unref0 (source_files);
}

static void
vala_flow_analyzer_real_visit_source_file (ValaCodeVisitor* base,
                                           ValaSourceFile* source_file)
{
	ValaFlowAnalyzer * self;
	self = (ValaFlowAnalyzer*) base;
	g_return_if_fail (source_file != NULL);
	vala_source_file_accept_children (source_file, (ValaCodeVisitor*) self);
}

static void
vala_flow_analyzer_real_visit_class (ValaCodeVisitor* base,
                                     ValaClass* cl)
{
	ValaFlowAnalyzer * self;
	self = (ValaFlowAnalyzer*) base;
	g_return_if_fail (cl != NULL);
	vala_code_node_accept_children ((ValaCodeNode*) cl, (ValaCodeVisitor*) self);
}

static void
vala_flow_analyzer_real_visit_struct (ValaCodeVisitor* base,
                                      ValaStruct* st)
{
	ValaFlowAnalyzer * self;
	self = (ValaFlowAnalyzer*) base;
	g_return_if_fail (st != NULL);
	vala_code_node_accept_children ((ValaCodeNode*) st, (ValaCodeVisitor*) self);
}

static void
vala_flow_analyzer_real_visit_interface (ValaCodeVisitor* base,
                                         ValaInterface* iface)
{
	ValaFlowAnalyzer * self;
	self = (ValaFlowAnalyzer*) base;
	g_return_if_fail (iface != NULL);
	vala_code_node_accept_children ((ValaCodeNode*) iface, (ValaCodeVisitor*) self);
}

static void
vala_flow_analyzer_real_visit_enum (ValaCodeVisitor* base,
                                    ValaEnum* en)
{
	ValaFlowAnalyzer * self;
	self = (ValaFlowAnalyzer*) base;
	g_return_if_fail (en != NULL);
	vala_code_node_accept_children ((ValaCodeNode*) en, (ValaCodeVisitor*) self);
}

static void
vala_flow_analyzer_real_visit_error_domain (ValaCodeVisitor* base,
                                            ValaErrorDomain* ed)
{
	ValaFlowAnalyzer * self;
	self = (ValaFlowAnalyzer*) base;
	g_return_if_fail (ed != NULL);
	vala_code_node_accept_children ((ValaCodeNode*) ed, (ValaCodeVisitor*) self);
}

static void
vala_flow_analyzer_real_visit_field (ValaCodeVisitor* base,
                                     ValaField* f)
{
	ValaFlowAnalyzer * self;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	self = (ValaFlowAnalyzer*) base;
	g_return_if_fail (f != NULL);
	if (vala_symbol_is_internal_symbol ((ValaSymbol*) f)) {
		gboolean _tmp2_;
		gboolean _tmp3_;
		_tmp2_ = vala_symbol_get_used ((ValaSymbol*) f);
		_tmp3_ = _tmp2_;
		_tmp1_ = !_tmp3_;
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		gboolean _tmp4_;
		gboolean _tmp5_;
		_tmp4_ = vala_symbol_get_external_package ((ValaSymbol*) f);
		_tmp5_ = _tmp4_;
		_tmp0_ = !_tmp5_;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		gboolean _tmp6_ = FALSE;
		if (!vala_symbol_is_private_symbol ((ValaSymbol*) f)) {
			gboolean _tmp7_ = FALSE;
			ValaCodeContext* _tmp8_;
			const gchar* _tmp9_;
			const gchar* _tmp10_;
			_tmp8_ = self->priv->context;
			_tmp9_ = vala_code_context_get_internal_header_filename (_tmp8_);
			_tmp10_ = _tmp9_;
			if (_tmp10_ != NULL) {
				_tmp7_ = TRUE;
			} else {
				ValaCodeContext* _tmp11_;
				gboolean _tmp12_;
				gboolean _tmp13_;
				_tmp11_ = self->priv->context;
				_tmp12_ = vala_code_context_get_use_fast_vapi (_tmp11_);
				_tmp13_ = _tmp12_;
				_tmp7_ = _tmp13_;
			}
			_tmp6_ = _tmp7_;
		} else {
			_tmp6_ = FALSE;
		}
		if (_tmp6_) {
		} else {
			ValaSourceReference* _tmp14_;
			ValaSourceReference* _tmp15_;
			gchar* _tmp16_;
			gchar* _tmp17_;
			gchar* _tmp18_;
			gchar* _tmp19_;
			_tmp14_ = vala_code_node_get_source_reference ((ValaCodeNode*) f);
			_tmp15_ = _tmp14_;
			_tmp16_ = vala_symbol_get_full_name ((ValaSymbol*) f);
			_tmp17_ = _tmp16_;
			_tmp18_ = g_strdup_printf ("field `%s' never used", _tmp17_);
			_tmp19_ = _tmp18_;
			vala_report_warning (_tmp15_, _tmp19_);
			_g_free0 (_tmp19_);
			_g_free0 (_tmp17_);
		}
	}
}

static gpointer
_vala_basic_block_ref0 (gpointer self)
{
	return self ? vala_basic_block_ref (self) : NULL;
}

static void
vala_flow_analyzer_real_visit_lambda_expression (ValaCodeVisitor* base,
                                                 ValaLambdaExpression* le)
{
	ValaFlowAnalyzer * self;
	ValaBasicBlock* old_current_block = NULL;
	ValaBasicBlock* _tmp0_;
	ValaBasicBlock* _tmp1_;
	gboolean old_unreachable_reported = FALSE;
	ValaList* old_jump_stack = NULL;
	ValaList* _tmp2_;
	ValaList* _tmp3_;
	GEqualFunc _tmp4_;
	ValaArrayList* _tmp5_;
	ValaBasicBlock* _tmp6_;
	ValaList* _tmp7_;
	self = (ValaFlowAnalyzer*) base;
	g_return_if_fail (le != NULL);
	_tmp0_ = self->priv->current_block;
	_tmp1_ = _vala_basic_block_ref0 (_tmp0_);
	old_current_block = _tmp1_;
	old_unreachable_reported = self->priv->unreachable_reported;
	_tmp2_ = self->priv->jump_stack;
	_tmp3_ = _vala_iterable_ref0 (_tmp2_);
	old_jump_stack = _tmp3_;
	vala_flow_analyzer_mark_unreachable (self);
	_tmp4_ = g_direct_equal;
	_tmp5_ = vala_array_list_new (VALA_FLOW_ANALYZER_TYPE_JUMP_TARGET, (GBoxedCopyFunc) vala_flow_analyzer_jump_target_ref, (GDestroyNotify) vala_flow_analyzer_jump_target_unref, _tmp4_);
	_vala_iterable_unref0 (self->priv->jump_stack);
	self->priv->jump_stack = (ValaList*) _tmp5_;
	vala_code_node_accept_children ((ValaCodeNode*) le, (ValaCodeVisitor*) self);
	_tmp6_ = _vala_basic_block_ref0 (old_current_block);
	_vala_basic_block_unref0 (self->priv->current_block);
	self->priv->current_block = _tmp6_;
	self->priv->unreachable_reported = old_unreachable_reported;
	_tmp7_ = _vala_iterable_ref0 (old_jump_stack);
	_vala_iterable_unref0 (self->priv->jump_stack);
	self->priv->jump_stack = _tmp7_;
	_vala_iterable_unref0 (old_jump_stack);
	_vala_basic_block_unref0 (old_current_block);
}

static void
vala_flow_analyzer_real_visit_method (ValaCodeVisitor* base,
                                      ValaMethod* m)
{
	ValaFlowAnalyzer * self;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp4_ = FALSE;
	gboolean _tmp5_ = FALSE;
	self = (ValaFlowAnalyzer*) base;
	g_return_if_fail (m != NULL);
	if (vala_symbol_is_internal_symbol ((ValaSymbol*) m)) {
		gboolean _tmp6_;
		gboolean _tmp7_;
		_tmp6_ = vala_symbol_get_used ((ValaSymbol*) m);
		_tmp7_ = _tmp6_;
		_tmp5_ = !_tmp7_;
	} else {
		_tmp5_ = FALSE;
	}
	if (_tmp5_) {
		gboolean _tmp8_;
		gboolean _tmp9_;
		_tmp8_ = vala_method_get_entry_point (m);
		_tmp9_ = _tmp8_;
		_tmp4_ = !_tmp9_;
	} else {
		_tmp4_ = FALSE;
	}
	if (_tmp4_) {
		gboolean _tmp10_;
		gboolean _tmp11_;
		_tmp10_ = vala_symbol_get_external_package ((ValaSymbol*) m);
		_tmp11_ = _tmp10_;
		_tmp3_ = !_tmp11_;
	} else {
		_tmp3_ = FALSE;
	}
	if (_tmp3_) {
		gboolean _tmp12_;
		gboolean _tmp13_;
		_tmp12_ = vala_method_get_overrides (m);
		_tmp13_ = _tmp12_;
		_tmp2_ = !_tmp13_;
	} else {
		_tmp2_ = FALSE;
	}
	if (_tmp2_) {
		gboolean _tmp14_ = FALSE;
		ValaMethod* _tmp15_;
		ValaMethod* _tmp16_;
		_tmp15_ = vala_method_get_base_interface_method (m);
		_tmp16_ = _tmp15_;
		if (_tmp16_ == NULL) {
			_tmp14_ = TRUE;
		} else {
			ValaMethod* _tmp17_;
			ValaMethod* _tmp18_;
			_tmp17_ = vala_method_get_base_interface_method (m);
			_tmp18_ = _tmp17_;
			_tmp14_ = _tmp18_ == m;
		}
		_tmp1_ = _tmp14_;
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		_tmp0_ = !VALA_IS_CREATION_METHOD (m);
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		gboolean _tmp19_ = FALSE;
		if (!vala_symbol_is_private_symbol ((ValaSymbol*) m)) {
			gboolean _tmp20_ = FALSE;
			ValaCodeContext* _tmp21_;
			const gchar* _tmp22_;
			const gchar* _tmp23_;
			_tmp21_ = self->priv->context;
			_tmp22_ = vala_code_context_get_internal_header_filename (_tmp21_);
			_tmp23_ = _tmp22_;
			if (_tmp23_ != NULL) {
				_tmp20_ = TRUE;
			} else {
				ValaCodeContext* _tmp24_;
				gboolean _tmp25_;
				gboolean _tmp26_;
				_tmp24_ = self->priv->context;
				_tmp25_ = vala_code_context_get_use_fast_vapi (_tmp24_);
				_tmp26_ = _tmp25_;
				_tmp20_ = _tmp26_;
			}
			_tmp19_ = _tmp20_;
		} else {
			_tmp19_ = FALSE;
		}
		if (_tmp19_) {
		} else {
			gboolean _tmp27_ = FALSE;
			gboolean _tmp28_ = FALSE;
			ValaSymbol* _tmp29_;
			ValaSymbol* _tmp30_;
			_tmp29_ = vala_symbol_get_parent_symbol ((ValaSymbol*) m);
			_tmp30_ = _tmp29_;
			if (_tmp30_ != NULL) {
				ValaSymbol* _tmp31_;
				ValaSymbol* _tmp32_;
				ValaAttribute* _tmp33_;
				_tmp31_ = vala_symbol_get_parent_symbol ((ValaSymbol*) m);
				_tmp32_ = _tmp31_;
				_tmp33_ = vala_code_node_get_attribute ((ValaCodeNode*) _tmp32_, "DBus");
				_tmp28_ = _tmp33_ != NULL;
			} else {
				_tmp28_ = FALSE;
			}
			if (_tmp28_) {
				_tmp27_ = vala_code_node_get_attribute_bool ((ValaCodeNode*) m, "DBus", "visible", TRUE);
			} else {
				_tmp27_ = FALSE;
			}
			if (_tmp27_) {
			} else {
				ValaSourceReference* _tmp34_;
				ValaSourceReference* _tmp35_;
				gchar* _tmp36_;
				gchar* _tmp37_;
				gchar* _tmp38_;
				gchar* _tmp39_;
				_tmp34_ = vala_code_node_get_source_reference ((ValaCodeNode*) m);
				_tmp35_ = _tmp34_;
				_tmp36_ = vala_symbol_get_full_name ((ValaSymbol*) m);
				_tmp37_ = _tmp36_;
				_tmp38_ = g_strdup_printf ("method `%s' never used", _tmp37_);
				_tmp39_ = _tmp38_;
				vala_report_warning (_tmp35_, _tmp39_);
				_g_free0 (_tmp39_);
				_g_free0 (_tmp37_);
			}
		}
	}
	vala_flow_analyzer_visit_subroutine (self, (ValaSubroutine*) m);
}

static void
vala_flow_analyzer_real_visit_signal (ValaCodeVisitor* base,
                                      ValaSignal* sig)
{
	ValaFlowAnalyzer * self;
	ValaMethod* _tmp0_;
	ValaMethod* _tmp1_;
	self = (ValaFlowAnalyzer*) base;
	g_return_if_fail (sig != NULL);
	_tmp0_ = vala_signal_get_default_handler (sig);
	_tmp1_ = _tmp0_;
	if (_tmp1_ != NULL) {
		ValaMethod* _tmp2_;
		ValaMethod* _tmp3_;
		_tmp2_ = vala_signal_get_default_handler (sig);
		_tmp3_ = _tmp2_;
		vala_flow_analyzer_visit_subroutine (self, (ValaSubroutine*) _tmp3_);
	}
}

static void
vala_flow_analyzer_visit_subroutine (ValaFlowAnalyzer* self,
                                     ValaSubroutine* m)
{
	ValaBlock* _tmp0_;
	ValaBlock* _tmp1_;
	ValaBasicBlock* _tmp2_;
	ValaBasicBlock* _tmp3_;
	ValaSet* _tmp4_;
	ValaBasicBlock* _tmp5_;
	ValaBasicBlock* _tmp6_;
	ValaBasicBlock* _tmp7_;
	ValaBasicBlock* _tmp8_;
	ValaSet* _tmp9_;
	ValaBasicBlock* _tmp10_;
	ValaBasicBlock* _tmp11_;
	ValaBasicBlock* _tmp12_;
	ValaBasicBlock* _tmp13_;
	ValaSet* _tmp14_;
	ValaBasicBlock* _tmp15_;
	ValaBasicBlock* _tmp16_;
	ValaBasicBlock* _tmp17_;
	ValaBasicBlock* _tmp18_;
	ValaBasicBlock* _tmp19_;
	ValaBasicBlock* _tmp20_;
	ValaBasicBlock* _tmp45_;
	ValaSet* _tmp46_;
	ValaBasicBlock* _tmp47_;
	ValaBasicBlock* _tmp48_;
	ValaBasicBlock* _tmp49_;
	ValaBasicBlock* _tmp50_;
	ValaBasicBlock* _tmp51_;
	ValaList* _tmp52_;
	ValaBasicBlock* _tmp53_;
	ValaBasicBlock* _tmp54_;
	ValaFlowAnalyzerJumpTarget* _tmp55_;
	ValaFlowAnalyzerJumpTarget* _tmp56_;
	ValaList* _tmp57_;
	ValaBasicBlock* _tmp58_;
	ValaBasicBlock* _tmp59_;
	ValaFlowAnalyzerJumpTarget* _tmp60_;
	ValaFlowAnalyzerJumpTarget* _tmp61_;
	ValaList* _tmp62_;
	ValaList* _tmp63_;
	gint _tmp64_;
	gint _tmp65_;
	gpointer _tmp66_;
	ValaFlowAnalyzerJumpTarget* _tmp67_;
	ValaBasicBlock* _tmp68_;
	ValaBasicBlock* _tmp76_;
	ValaBasicBlock* _tmp77_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (m != NULL);
	_tmp0_ = vala_subroutine_get_body (m);
	_tmp1_ = _tmp0_;
	if (_tmp1_ == NULL) {
		return;
	}
	_tmp2_ = vala_basic_block_new_entry ();
	_tmp3_ = _tmp2_;
	vala_subroutine_set_entry_block (m, _tmp3_);
	_vala_basic_block_unref0 (_tmp3_);
	_tmp4_ = self->priv->all_basic_blocks;
	_tmp5_ = vala_subroutine_get_entry_block (m);
	_tmp6_ = _tmp5_;
	vala_collection_add ((ValaCollection*) _tmp4_, _tmp6_);
	_tmp7_ = vala_basic_block_new ();
	_tmp8_ = _tmp7_;
	vala_subroutine_set_return_block (m, _tmp8_);
	_vala_basic_block_unref0 (_tmp8_);
	_tmp9_ = self->priv->all_basic_blocks;
	_tmp10_ = vala_subroutine_get_return_block (m);
	_tmp11_ = _tmp10_;
	vala_collection_add ((ValaCollection*) _tmp9_, _tmp11_);
	_tmp12_ = vala_basic_block_new_exit ();
	_tmp13_ = _tmp12_;
	vala_subroutine_set_exit_block (m, _tmp13_);
	_vala_basic_block_unref0 (_tmp13_);
	_tmp14_ = self->priv->all_basic_blocks;
	_tmp15_ = vala_subroutine_get_exit_block (m);
	_tmp16_ = _tmp15_;
	vala_collection_add ((ValaCollection*) _tmp14_, _tmp16_);
	_tmp17_ = vala_subroutine_get_return_block (m);
	_tmp18_ = _tmp17_;
	_tmp19_ = vala_subroutine_get_exit_block (m);
	_tmp20_ = _tmp19_;
	vala_basic_block_connect (_tmp18_, _tmp20_);
	if (VALA_IS_METHOD (m)) {
		{
			ValaList* _param_list = NULL;
			ValaList* _tmp21_;
			ValaList* _tmp22_;
			gint _param_size = 0;
			ValaList* _tmp23_;
			gint _tmp24_;
			gint _tmp25_;
			gint _param_index = 0;
			_tmp21_ = vala_callable_get_parameters ((ValaCallable*) G_TYPE_CHECK_INSTANCE_CAST (m, VALA_TYPE_METHOD, ValaMethod));
			_tmp22_ = _vala_iterable_ref0 (_tmp21_);
			_param_list = _tmp22_;
			_tmp23_ = _param_list;
			_tmp24_ = vala_collection_get_size ((ValaCollection*) _tmp23_);
			_tmp25_ = _tmp24_;
			_param_size = _tmp25_;
			_param_index = -1;
			while (TRUE) {
				gint _tmp26_;
				gint _tmp27_;
				ValaParameter* param = NULL;
				ValaList* _tmp28_;
				gpointer _tmp29_;
				ValaParameter* _tmp30_;
				ValaParameterDirection _tmp31_;
				ValaParameterDirection _tmp32_;
				_param_index = _param_index + 1;
				_tmp26_ = _param_index;
				_tmp27_ = _param_size;
				if (!(_tmp26_ < _tmp27_)) {
					break;
				}
				_tmp28_ = _param_list;
				_tmp29_ = vala_list_get (_tmp28_, _param_index);
				param = (ValaParameter*) _tmp29_;
				_tmp30_ = param;
				_tmp31_ = vala_parameter_get_direction (_tmp30_);
				_tmp32_ = _tmp31_;
				if (_tmp32_ == VALA_PARAMETER_DIRECTION_OUT) {
					ValaMemberAccess* param_ma = NULL;
					ValaParameter* _tmp33_;
					const gchar* _tmp34_;
					const gchar* _tmp35_;
					ValaParameter* _tmp36_;
					ValaSourceReference* _tmp37_;
					ValaSourceReference* _tmp38_;
					ValaMemberAccess* _tmp39_;
					ValaMemberAccess* _tmp40_;
					ValaParameter* _tmp41_;
					ValaBasicBlock* _tmp42_;
					ValaBasicBlock* _tmp43_;
					ValaMemberAccess* _tmp44_;
					_tmp33_ = param;
					_tmp34_ = vala_symbol_get_name ((ValaSymbol*) _tmp33_);
					_tmp35_ = _tmp34_;
					_tmp36_ = param;
					_tmp37_ = vala_code_node_get_source_reference ((ValaCodeNode*) _tmp36_);
					_tmp38_ = _tmp37_;
					_tmp39_ = vala_member_access_new_simple (_tmp35_, _tmp38_);
					param_ma = _tmp39_;
					_tmp40_ = param_ma;
					_tmp41_ = param;
					vala_expression_set_symbol_reference ((ValaExpression*) _tmp40_, (ValaSymbol*) _tmp41_);
					_tmp42_ = vala_subroutine_get_return_block (m);
					_tmp43_ = _tmp42_;
					_tmp44_ = param_ma;
					vala_basic_block_add_node (_tmp43_, (ValaCodeNode*) _tmp44_);
					_vala_code_node_unref0 (param_ma);
				}
				_vala_code_node_unref0 (param);
			}
			_vala_iterable_unref0 (_param_list);
		}
	}
	_tmp45_ = vala_basic_block_new ();
	_vala_basic_block_unref0 (self->priv->current_block);
	self->priv->current_block = _tmp45_;
	_tmp46_ = self->priv->all_basic_blocks;
	_tmp47_ = self->priv->current_block;
	vala_collection_add ((ValaCollection*) _tmp46_, _tmp47_);
	_tmp48_ = vala_subroutine_get_entry_block (m);
	_tmp49_ = _tmp48_;
	_tmp50_ = self->priv->current_block;
	vala_basic_block_connect (_tmp49_, _tmp50_);
	_tmp51_ = self->priv->current_block;
	vala_basic_block_add_node (_tmp51_, (ValaCodeNode*) m);
	_tmp52_ = self->priv->jump_stack;
	_tmp53_ = vala_subroutine_get_return_block (m);
	_tmp54_ = _tmp53_;
	_tmp55_ = vala_flow_analyzer_jump_target_new_return_target (_tmp54_);
	_tmp56_ = _tmp55_;
	vala_collection_add ((ValaCollection*) _tmp52_, _tmp56_);
	_vala_flow_analyzer_jump_target_unref0 (_tmp56_);
	_tmp57_ = self->priv->jump_stack;
	_tmp58_ = vala_subroutine_get_exit_block (m);
	_tmp59_ = _tmp58_;
	_tmp60_ = vala_flow_analyzer_jump_target_new_exit_target (_tmp59_);
	_tmp61_ = _tmp60_;
	vala_collection_add ((ValaCollection*) _tmp57_, _tmp61_);
	_vala_flow_analyzer_jump_target_unref0 (_tmp61_);
	vala_code_node_accept_children ((ValaCodeNode*) m, (ValaCodeVisitor*) self);
	_tmp62_ = self->priv->jump_stack;
	_tmp63_ = self->priv->jump_stack;
	_tmp64_ = vala_collection_get_size ((ValaCollection*) _tmp63_);
	_tmp65_ = _tmp64_;
	_tmp66_ = vala_list_remove_at (_tmp62_, _tmp65_ - 1);
	_tmp67_ = (ValaFlowAnalyzerJumpTarget*) _tmp66_;
	_vala_flow_analyzer_jump_target_unref0 (_tmp67_);
	_tmp68_ = self->priv->current_block;
	if (_tmp68_ != NULL) {
		gboolean _tmp69_;
		gboolean _tmp70_;
		ValaBasicBlock* _tmp73_;
		ValaBasicBlock* _tmp74_;
		ValaBasicBlock* _tmp75_;
		_tmp69_ = vala_subroutine_get_has_result (m);
		_tmp70_ = _tmp69_;
		if (_tmp70_) {
			ValaSourceReference* _tmp71_;
			ValaSourceReference* _tmp72_;
			_tmp71_ = vala_code_node_get_source_reference ((ValaCodeNode*) m);
			_tmp72_ = _tmp71_;
			vala_report_error (_tmp72_, "missing return statement at end of subroutine body");
			vala_code_node_set_error ((ValaCodeNode*) m, TRUE);
		}
		_tmp73_ = self->priv->current_block;
		_tmp74_ = vala_subroutine_get_return_block (m);
		_tmp75_ = _tmp74_;
		vala_basic_block_connect (_tmp73_, _tmp75_);
	}
	_tmp76_ = vala_subroutine_get_entry_block (m);
	_tmp77_ = _tmp76_;
	vala_flow_analyzer_analyze_body (self, _tmp77_);
}

static void
vala_flow_analyzer_analyze_body (ValaFlowAnalyzer* self,
                                 ValaBasicBlock* entry_block)
{
	ValaList* block_list = NULL;
	ValaList* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (entry_block != NULL);
	_tmp0_ = vala_flow_analyzer_get_depth_first_list (self, entry_block);
	block_list = _tmp0_;
	vala_flow_analyzer_build_dominator_tree (self, block_list, entry_block);
	vala_flow_analyzer_build_dominator_frontier (self, block_list, entry_block);
	vala_flow_analyzer_insert_phi_functions (self, block_list, entry_block);
	vala_flow_analyzer_check_variables (self, entry_block);
	_vala_iterable_unref0 (block_list);
}

static ValaList*
vala_flow_analyzer_get_depth_first_list (ValaFlowAnalyzer* self,
                                         ValaBasicBlock* entry_block)
{
	ValaArrayList* list = NULL;
	GEqualFunc _tmp0_;
	ValaArrayList* _tmp1_;
	ValaList* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (entry_block != NULL, NULL);
	_tmp0_ = g_direct_equal;
	_tmp1_ = vala_array_list_new (VALA_TYPE_BASIC_BLOCK, (GBoxedCopyFunc) vala_basic_block_ref, (GDestroyNotify) vala_basic_block_unref, _tmp0_);
	list = _tmp1_;
	vala_flow_analyzer_depth_first_traverse (self, entry_block, (ValaList*) list);
	result = (ValaList*) list;
	return result;
}

static void
vala_flow_analyzer_depth_first_traverse (ValaFlowAnalyzer* self,
                                         ValaBasicBlock* current,
                                         ValaList* list)
{
	gboolean _tmp0_;
	gboolean _tmp1_;
	gint _tmp12_;
	gint _tmp13_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (current != NULL);
	g_return_if_fail (list != NULL);
	_tmp0_ = vala_basic_block_get_postorder_visited (current);
	_tmp1_ = _tmp0_;
	if (_tmp1_) {
		return;
	}
	vala_basic_block_set_postorder_visited (current, TRUE);
	{
		ValaList* _succ_list = NULL;
		ValaList* _tmp2_;
		ValaList* _tmp3_;
		gint _succ_size = 0;
		ValaList* _tmp4_;
		gint _tmp5_;
		gint _tmp6_;
		gint _succ_index = 0;
		_tmp2_ = vala_basic_block_get_successors (current);
		_tmp3_ = _vala_iterable_ref0 (_tmp2_);
		_succ_list = _tmp3_;
		_tmp4_ = _succ_list;
		_tmp5_ = vala_collection_get_size ((ValaCollection*) _tmp4_);
		_tmp6_ = _tmp5_;
		_succ_size = _tmp6_;
		_succ_index = -1;
		while (TRUE) {
			gint _tmp7_;
			gint _tmp8_;
			ValaBasicBlock* succ = NULL;
			ValaList* _tmp9_;
			gpointer _tmp10_;
			ValaBasicBlock* _tmp11_;
			_succ_index = _succ_index + 1;
			_tmp7_ = _succ_index;
			_tmp8_ = _succ_size;
			if (!(_tmp7_ < _tmp8_)) {
				break;
			}
			_tmp9_ = _succ_list;
			_tmp10_ = vala_list_get (_tmp9_, _succ_index);
			succ = (ValaBasicBlock*) _tmp10_;
			_tmp11_ = succ;
			vala_flow_analyzer_depth_first_traverse (self, _tmp11_, list);
		}
		_vala_iterable_unref0 (_succ_list);
	}
	_tmp12_ = vala_collection_get_size ((ValaCollection*) list);
	_tmp13_ = _tmp12_;
	vala_basic_block_set_postorder_number (current, _tmp13_);
	vala_list_insert (list, 0, current);
}

static void
vala_flow_analyzer_build_dominator_tree (ValaFlowAnalyzer* self,
                                         ValaList* block_list,
                                         ValaBasicBlock* entry_block)
{
	ValaBasicBlock** idoms = NULL;
	gint _tmp0_;
	gint _tmp1_;
	ValaBasicBlock** _tmp2_;
	gint idoms_length1;
	gint _idoms_size_;
	ValaBasicBlock** _tmp3_;
	gint _tmp3__length1;
	gint _tmp4_;
	gint _tmp5_;
	ValaBasicBlock* _tmp6_;
	gboolean changed = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (block_list != NULL);
	g_return_if_fail (entry_block != NULL);
	_tmp0_ = vala_collection_get_size ((ValaCollection*) block_list);
	_tmp1_ = _tmp0_;
	_tmp2_ = g_new0 (ValaBasicBlock*, _tmp1_ + 1);
	idoms = _tmp2_;
	idoms_length1 = _tmp1_;
	_idoms_size_ = idoms_length1;
	_tmp3_ = idoms;
	_tmp3__length1 = idoms_length1;
	_tmp4_ = vala_basic_block_get_postorder_number (entry_block);
	_tmp5_ = _tmp4_;
	_tmp6_ = _vala_basic_block_ref0 (entry_block);
	_vala_basic_block_unref0 (_tmp3_[_tmp5_]);
	_tmp3_[_tmp5_] = _tmp6_;
	changed = TRUE;
	while (TRUE) {
		if (!changed) {
			break;
		}
		changed = FALSE;
		{
			ValaList* _block_list = NULL;
			ValaList* _tmp7_;
			gint _block_size = 0;
			ValaList* _tmp8_;
			gint _tmp9_;
			gint _tmp10_;
			gint _block_index = 0;
			_tmp7_ = _vala_iterable_ref0 (block_list);
			_block_list = _tmp7_;
			_tmp8_ = _block_list;
			_tmp9_ = vala_collection_get_size ((ValaCollection*) _tmp8_);
			_tmp10_ = _tmp9_;
			_block_size = _tmp10_;
			_block_index = -1;
			while (TRUE) {
				gint _tmp11_;
				gint _tmp12_;
				ValaBasicBlock* block = NULL;
				ValaList* _tmp13_;
				gpointer _tmp14_;
				ValaBasicBlock* _tmp15_;
				ValaBasicBlock* new_idom = NULL;
				gboolean first = FALSE;
				ValaBasicBlock** _tmp37_;
				gint _tmp37__length1;
				ValaBasicBlock* _tmp38_;
				gint _tmp39_;
				gint _tmp40_;
				ValaBasicBlock* _tmp41_;
				ValaBasicBlock* _tmp42_;
				_block_index = _block_index + 1;
				_tmp11_ = _block_index;
				_tmp12_ = _block_size;
				if (!(_tmp11_ < _tmp12_)) {
					break;
				}
				_tmp13_ = _block_list;
				_tmp14_ = vala_list_get (_tmp13_, _block_index);
				block = (ValaBasicBlock*) _tmp14_;
				_tmp15_ = block;
				if (_tmp15_ == entry_block) {
					_vala_basic_block_unref0 (block);
					continue;
				}
				new_idom = NULL;
				first = TRUE;
				{
					ValaList* _pred_list = NULL;
					ValaBasicBlock* _tmp16_;
					ValaList* _tmp17_;
					ValaList* _tmp18_;
					gint _pred_size = 0;
					ValaList* _tmp19_;
					gint _tmp20_;
					gint _tmp21_;
					gint _pred_index = 0;
					_tmp16_ = block;
					_tmp17_ = vala_basic_block_get_predecessors (_tmp16_);
					_tmp18_ = _vala_iterable_ref0 (_tmp17_);
					_pred_list = _tmp18_;
					_tmp19_ = _pred_list;
					_tmp20_ = vala_collection_get_size ((ValaCollection*) _tmp19_);
					_tmp21_ = _tmp20_;
					_pred_size = _tmp21_;
					_pred_index = -1;
					while (TRUE) {
						gint _tmp22_;
						gint _tmp23_;
						ValaBasicBlock* pred = NULL;
						ValaList* _tmp24_;
						gpointer _tmp25_;
						ValaBasicBlock** _tmp26_;
						gint _tmp26__length1;
						ValaBasicBlock* _tmp27_;
						gint _tmp28_;
						gint _tmp29_;
						ValaBasicBlock* _tmp30_;
						_pred_index = _pred_index + 1;
						_tmp22_ = _pred_index;
						_tmp23_ = _pred_size;
						if (!(_tmp22_ < _tmp23_)) {
							break;
						}
						_tmp24_ = _pred_list;
						_tmp25_ = vala_list_get (_tmp24_, _pred_index);
						pred = (ValaBasicBlock*) _tmp25_;
						_tmp26_ = idoms;
						_tmp26__length1 = idoms_length1;
						_tmp27_ = pred;
						_tmp28_ = vala_basic_block_get_postorder_number (_tmp27_);
						_tmp29_ = _tmp28_;
						_tmp30_ = _tmp26_[_tmp29_];
						if (_tmp30_ != NULL) {
							if (first) {
								ValaBasicBlock* _tmp31_;
								ValaBasicBlock* _tmp32_;
								_tmp31_ = pred;
								_tmp32_ = _vala_basic_block_ref0 (_tmp31_);
								_vala_basic_block_unref0 (new_idom);
								new_idom = _tmp32_;
								first = FALSE;
							} else {
								ValaBasicBlock** _tmp33_;
								gint _tmp33__length1;
								ValaBasicBlock* _tmp34_;
								ValaBasicBlock* _tmp35_;
								ValaBasicBlock* _tmp36_;
								_tmp33_ = idoms;
								_tmp33__length1 = idoms_length1;
								_tmp34_ = pred;
								_tmp35_ = new_idom;
								_tmp36_ = vala_flow_analyzer_intersect (self, _tmp33_, (gint) _tmp33__length1, _tmp34_, _tmp35_);
								_vala_basic_block_unref0 (new_idom);
								new_idom = _tmp36_;
							}
						}
					}
					_vala_iterable_unref0 (_pred_list);
				}
				_tmp37_ = idoms;
				_tmp37__length1 = idoms_length1;
				_tmp38_ = block;
				_tmp39_ = vala_basic_block_get_postorder_number (_tmp38_);
				_tmp40_ = _tmp39_;
				_tmp41_ = _tmp37_[_tmp40_];
				_tmp42_ = new_idom;
				if (_tmp41_ != _tmp42_) {
					ValaBasicBlock** _tmp43_;
					gint _tmp43__length1;
					ValaBasicBlock* _tmp44_;
					gint _tmp45_;
					gint _tmp46_;
					ValaBasicBlock* _tmp47_;
					ValaBasicBlock* _tmp48_;
					_tmp43_ = idoms;
					_tmp43__length1 = idoms_length1;
					_tmp44_ = block;
					_tmp45_ = vala_basic_block_get_postorder_number (_tmp44_);
					_tmp46_ = _tmp45_;
					_tmp47_ = new_idom;
					_tmp48_ = _vala_basic_block_ref0 (_tmp47_);
					_vala_basic_block_unref0 (_tmp43_[_tmp46_]);
					_tmp43_[_tmp46_] = _tmp48_;
					changed = TRUE;
				}
				_vala_basic_block_unref0 (new_idom);
				_vala_basic_block_unref0 (block);
			}
			_vala_iterable_unref0 (_block_list);
		}
	}
	{
		ValaList* _block_list = NULL;
		ValaList* _tmp49_;
		gint _block_size = 0;
		ValaList* _tmp50_;
		gint _tmp51_;
		gint _tmp52_;
		gint _block_index = 0;
		_tmp49_ = _vala_iterable_ref0 (block_list);
		_block_list = _tmp49_;
		_tmp50_ = _block_list;
		_tmp51_ = vala_collection_get_size ((ValaCollection*) _tmp50_);
		_tmp52_ = _tmp51_;
		_block_size = _tmp52_;
		_block_index = -1;
		while (TRUE) {
			gint _tmp53_;
			gint _tmp54_;
			ValaBasicBlock* block = NULL;
			ValaList* _tmp55_;
			gpointer _tmp56_;
			ValaBasicBlock* _tmp57_;
			ValaBasicBlock** _tmp58_;
			gint _tmp58__length1;
			ValaBasicBlock* _tmp59_;
			gint _tmp60_;
			gint _tmp61_;
			ValaBasicBlock* _tmp62_;
			ValaBasicBlock* _tmp63_;
			_block_index = _block_index + 1;
			_tmp53_ = _block_index;
			_tmp54_ = _block_size;
			if (!(_tmp53_ < _tmp54_)) {
				break;
			}
			_tmp55_ = _block_list;
			_tmp56_ = vala_list_get (_tmp55_, _block_index);
			block = (ValaBasicBlock*) _tmp56_;
			_tmp57_ = block;
			if (_tmp57_ == entry_block) {
				_vala_basic_block_unref0 (block);
				continue;
			}
			_tmp58_ = idoms;
			_tmp58__length1 = idoms_length1;
			_tmp59_ = block;
			_tmp60_ = vala_basic_block_get_postorder_number (_tmp59_);
			_tmp61_ = _tmp60_;
			_tmp62_ = _tmp58_[_tmp61_];
			_tmp63_ = block;
			vala_basic_block_add_child (_tmp62_, _tmp63_);
			_vala_basic_block_unref0 (block);
		}
		_vala_iterable_unref0 (_block_list);
	}
	idoms = (_vala_array_free (idoms, idoms_length1, (GDestroyNotify) vala_basic_block_unref), NULL);
}

static ValaBasicBlock*
vala_flow_analyzer_intersect (ValaFlowAnalyzer* self,
                              ValaBasicBlock** idoms,
                              gint idoms_length1,
                              ValaBasicBlock* b1,
                              ValaBasicBlock* b2)
{
	ValaBasicBlock* _tmp14_;
	ValaBasicBlock* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (b1 != NULL, NULL);
	g_return_val_if_fail (b2 != NULL, NULL);
	while (TRUE) {
		if (!(b1 != b2)) {
			break;
		}
		while (TRUE) {
			gint _tmp0_;
			gint _tmp1_;
			gint _tmp2_;
			gint _tmp3_;
			gint _tmp4_;
			gint _tmp5_;
			ValaBasicBlock* _tmp6_;
			_tmp0_ = vala_basic_block_get_postorder_number (b1);
			_tmp1_ = _tmp0_;
			_tmp2_ = vala_basic_block_get_postorder_number (b2);
			_tmp3_ = _tmp2_;
			if (!(_tmp1_ < _tmp3_)) {
				break;
			}
			_tmp4_ = vala_basic_block_get_postorder_number (b2);
			_tmp5_ = _tmp4_;
			_tmp6_ = idoms[_tmp5_];
			b1 = _tmp6_;
		}
		while (TRUE) {
			gint _tmp7_;
			gint _tmp8_;
			gint _tmp9_;
			gint _tmp10_;
			gint _tmp11_;
			gint _tmp12_;
			ValaBasicBlock* _tmp13_;
			_tmp7_ = vala_basic_block_get_postorder_number (b2);
			_tmp8_ = _tmp7_;
			_tmp9_ = vala_basic_block_get_postorder_number (b1);
			_tmp10_ = _tmp9_;
			if (!(_tmp8_ < _tmp10_)) {
				break;
			}
			_tmp11_ = vala_basic_block_get_postorder_number (b2);
			_tmp12_ = _tmp11_;
			_tmp13_ = idoms[_tmp12_];
			b2 = _tmp13_;
		}
	}
	_tmp14_ = _vala_basic_block_ref0 (b1);
	result = _tmp14_;
	return result;
}

static void
vala_flow_analyzer_build_dominator_frontier (ValaFlowAnalyzer* self,
                                             ValaList* block_list,
                                             ValaBasicBlock* entry_block)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (block_list != NULL);
	g_return_if_fail (entry_block != NULL);
	{
		gint i = 0;
		gint _tmp0_;
		gint _tmp1_;
		_tmp0_ = vala_collection_get_size ((ValaCollection*) block_list);
		_tmp1_ = _tmp0_;
		i = _tmp1_ - 1;
		{
			gboolean _tmp2_ = FALSE;
			_tmp2_ = TRUE;
			while (TRUE) {
				ValaBasicBlock* block = NULL;
				gpointer _tmp4_;
				if (!_tmp2_) {
					gint _tmp3_;
					_tmp3_ = i;
					i = _tmp3_ - 1;
				}
				_tmp2_ = FALSE;
				if (!(i >= 0)) {
					break;
				}
				_tmp4_ = vala_list_get (block_list, i);
				block = (ValaBasicBlock*) _tmp4_;
				{
					ValaList* _succ_list = NULL;
					ValaBasicBlock* _tmp5_;
					ValaList* _tmp6_;
					ValaList* _tmp7_;
					gint _succ_size = 0;
					ValaList* _tmp8_;
					gint _tmp9_;
					gint _tmp10_;
					gint _succ_index = 0;
					_tmp5_ = block;
					_tmp6_ = vala_basic_block_get_successors (_tmp5_);
					_tmp7_ = _vala_iterable_ref0 (_tmp6_);
					_succ_list = _tmp7_;
					_tmp8_ = _succ_list;
					_tmp9_ = vala_collection_get_size ((ValaCollection*) _tmp8_);
					_tmp10_ = _tmp9_;
					_succ_size = _tmp10_;
					_succ_index = -1;
					while (TRUE) {
						gint _tmp11_;
						gint _tmp12_;
						ValaBasicBlock* succ = NULL;
						ValaList* _tmp13_;
						gpointer _tmp14_;
						ValaBasicBlock* _tmp15_;
						ValaBasicBlock* _tmp16_;
						ValaBasicBlock* _tmp17_;
						ValaBasicBlock* _tmp18_;
						_succ_index = _succ_index + 1;
						_tmp11_ = _succ_index;
						_tmp12_ = _succ_size;
						if (!(_tmp11_ < _tmp12_)) {
							break;
						}
						_tmp13_ = _succ_list;
						_tmp14_ = vala_list_get (_tmp13_, _succ_index);
						succ = (ValaBasicBlock*) _tmp14_;
						_tmp15_ = succ;
						_tmp16_ = vala_basic_block_get_parent (_tmp15_);
						_tmp17_ = _tmp16_;
						_tmp18_ = block;
						if (_tmp17_ != _tmp18_) {
							ValaBasicBlock* _tmp19_;
							ValaBasicBlock* _tmp20_;
							_tmp19_ = block;
							_tmp20_ = succ;
							vala_basic_block_add_dominator_frontier (_tmp19_, _tmp20_);
						}
					}
					_vala_iterable_unref0 (_succ_list);
				}
				{
					ValaList* _child_list = NULL;
					ValaBasicBlock* _tmp21_;
					ValaList* _tmp22_;
					ValaList* _tmp23_;
					gint _child_size = 0;
					ValaList* _tmp24_;
					gint _tmp25_;
					gint _tmp26_;
					gint _child_index = 0;
					_tmp21_ = block;
					_tmp22_ = vala_basic_block_get_children (_tmp21_);
					_tmp23_ = _vala_iterable_ref0 (_tmp22_);
					_child_list = _tmp23_;
					_tmp24_ = _child_list;
					_tmp25_ = vala_collection_get_size ((ValaCollection*) _tmp24_);
					_tmp26_ = _tmp25_;
					_child_size = _tmp26_;
					_child_index = -1;
					while (TRUE) {
						gint _tmp27_;
						gint _tmp28_;
						ValaBasicBlock* child = NULL;
						ValaList* _tmp29_;
						gpointer _tmp30_;
						_child_index = _child_index + 1;
						_tmp27_ = _child_index;
						_tmp28_ = _child_size;
						if (!(_tmp27_ < _tmp28_)) {
							break;
						}
						_tmp29_ = _child_list;
						_tmp30_ = vala_list_get (_tmp29_, _child_index);
						child = (ValaBasicBlock*) _tmp30_;
						{
							ValaIterator* _child_frontier_it = NULL;
							ValaBasicBlock* _tmp31_;
							ValaSet* _tmp32_;
							ValaIterator* _tmp33_;
							_tmp31_ = child;
							_tmp32_ = vala_basic_block_get_dominator_frontier (_tmp31_);
							_tmp33_ = vala_iterable_iterator ((ValaIterable*) _tmp32_);
							_child_frontier_it = _tmp33_;
							while (TRUE) {
								ValaIterator* _tmp34_;
								ValaBasicBlock* child_frontier = NULL;
								ValaIterator* _tmp35_;
								gpointer _tmp36_;
								ValaBasicBlock* _tmp37_;
								ValaBasicBlock* _tmp38_;
								ValaBasicBlock* _tmp39_;
								ValaBasicBlock* _tmp40_;
								_tmp34_ = _child_frontier_it;
								if (!vala_iterator_next (_tmp34_)) {
									break;
								}
								_tmp35_ = _child_frontier_it;
								_tmp36_ = vala_iterator_get (_tmp35_);
								child_frontier = (ValaBasicBlock*) _tmp36_;
								_tmp37_ = child_frontier;
								_tmp38_ = vala_basic_block_get_parent (_tmp37_);
								_tmp39_ = _tmp38_;
								_tmp40_ = block;
								if (_tmp39_ != _tmp40_) {
									ValaBasicBlock* _tmp41_;
									ValaBasicBlock* _tmp42_;
									_tmp41_ = block;
									_tmp42_ = child_frontier;
									vala_basic_block_add_dominator_frontier (_tmp41_, _tmp42_);
								}
							}
							_vala_iterator_unref0 (_child_frontier_it);
						}
					}
					_vala_iterable_unref0 (_child_list);
				}
				_vala_basic_block_unref0 (block);
			}
		}
	}
}

static ValaMap*
vala_flow_analyzer_get_assignment_map (ValaFlowAnalyzer* self,
                                       ValaList* block_list,
                                       ValaBasicBlock* entry_block)
{
	ValaHashMap* map = NULL;
	GHashFunc _tmp0_;
	GEqualFunc _tmp1_;
	GEqualFunc _tmp2_;
	ValaHashMap* _tmp3_;
	ValaMap* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (block_list != NULL, NULL);
	g_return_val_if_fail (entry_block != NULL, NULL);
	_tmp0_ = g_direct_hash;
	_tmp1_ = g_direct_equal;
	_tmp2_ = g_direct_equal;
	_tmp3_ = vala_hash_map_new (VALA_TYPE_VARIABLE, (GBoxedCopyFunc) vala_code_node_ref, (GDestroyNotify) vala_code_node_unref, VALA_TYPE_SET, (GBoxedCopyFunc) vala_iterable_ref, (GDestroyNotify) vala_iterable_unref, _tmp0_, _tmp1_, _tmp2_);
	map = _tmp3_;
	{
		ValaList* _block_list = NULL;
		ValaList* _tmp4_;
		gint _block_size = 0;
		ValaList* _tmp5_;
		gint _tmp6_;
		gint _tmp7_;
		gint _block_index = 0;
		_tmp4_ = _vala_iterable_ref0 (block_list);
		_block_list = _tmp4_;
		_tmp5_ = _block_list;
		_tmp6_ = vala_collection_get_size ((ValaCollection*) _tmp5_);
		_tmp7_ = _tmp6_;
		_block_size = _tmp7_;
		_block_index = -1;
		while (TRUE) {
			gint _tmp8_;
			gint _tmp9_;
			ValaBasicBlock* block = NULL;
			ValaList* _tmp10_;
			gpointer _tmp11_;
			ValaArrayList* defined_variables = NULL;
			GEqualFunc _tmp12_;
			ValaArrayList* _tmp13_;
			_block_index = _block_index + 1;
			_tmp8_ = _block_index;
			_tmp9_ = _block_size;
			if (!(_tmp8_ < _tmp9_)) {
				break;
			}
			_tmp10_ = _block_list;
			_tmp11_ = vala_list_get (_tmp10_, _block_index);
			block = (ValaBasicBlock*) _tmp11_;
			_tmp12_ = g_direct_equal;
			_tmp13_ = vala_array_list_new (VALA_TYPE_VARIABLE, (GBoxedCopyFunc) vala_code_node_ref, (GDestroyNotify) vala_code_node_unref, _tmp12_);
			defined_variables = _tmp13_;
			{
				ValaList* _node_list = NULL;
				ValaBasicBlock* _tmp14_;
				ValaList* _tmp15_;
				ValaList* _tmp16_;
				gint _node_size = 0;
				ValaList* _tmp17_;
				gint _tmp18_;
				gint _tmp19_;
				gint _node_index = 0;
				_tmp14_ = block;
				_tmp15_ = vala_basic_block_get_nodes (_tmp14_);
				_tmp16_ = _vala_iterable_ref0 (_tmp15_);
				_node_list = _tmp16_;
				_tmp17_ = _node_list;
				_tmp18_ = vala_collection_get_size ((ValaCollection*) _tmp17_);
				_tmp19_ = _tmp18_;
				_node_size = _tmp19_;
				_node_index = -1;
				while (TRUE) {
					gint _tmp20_;
					gint _tmp21_;
					ValaCodeNode* node = NULL;
					ValaList* _tmp22_;
					gpointer _tmp23_;
					ValaCodeNode* _tmp24_;
					ValaArrayList* _tmp25_;
					_node_index = _node_index + 1;
					_tmp20_ = _node_index;
					_tmp21_ = _node_size;
					if (!(_tmp20_ < _tmp21_)) {
						break;
					}
					_tmp22_ = _node_list;
					_tmp23_ = vala_list_get (_tmp22_, _node_index);
					node = (ValaCodeNode*) _tmp23_;
					_tmp24_ = node;
					_tmp25_ = defined_variables;
					vala_code_node_get_defined_variables (_tmp24_, (ValaCollection*) _tmp25_);
					_vala_code_node_unref0 (node);
				}
				_vala_iterable_unref0 (_node_list);
			}
			{
				ValaArrayList* _variable_list = NULL;
				ValaArrayList* _tmp26_;
				ValaArrayList* _tmp27_;
				gint _variable_size = 0;
				ValaArrayList* _tmp28_;
				gint _tmp29_;
				gint _tmp30_;
				gint _variable_index = 0;
				_tmp26_ = defined_variables;
				_tmp27_ = _vala_iterable_ref0 (_tmp26_);
				_variable_list = _tmp27_;
				_tmp28_ = _variable_list;
				_tmp29_ = vala_collection_get_size ((ValaCollection*) _tmp28_);
				_tmp30_ = _tmp29_;
				_variable_size = _tmp30_;
				_variable_index = -1;
				while (TRUE) {
					gint _tmp31_;
					gint _tmp32_;
					ValaVariable* variable = NULL;
					ValaArrayList* _tmp33_;
					gpointer _tmp34_;
					ValaSet* block_set = NULL;
					ValaHashMap* _tmp35_;
					ValaVariable* _tmp36_;
					gpointer _tmp37_;
					ValaSet* _tmp38_;
					ValaSet* _tmp45_;
					ValaBasicBlock* _tmp46_;
					_variable_index = _variable_index + 1;
					_tmp31_ = _variable_index;
					_tmp32_ = _variable_size;
					if (!(_tmp31_ < _tmp32_)) {
						break;
					}
					_tmp33_ = _variable_list;
					_tmp34_ = vala_list_get ((ValaList*) _tmp33_, _variable_index);
					variable = (ValaVariable*) _tmp34_;
					_tmp35_ = map;
					_tmp36_ = variable;
					_tmp37_ = vala_map_get ((ValaMap*) _tmp35_, _tmp36_);
					block_set = (ValaSet*) _tmp37_;
					_tmp38_ = block_set;
					if (_tmp38_ == NULL) {
						GHashFunc _tmp39_;
						GEqualFunc _tmp40_;
						ValaHashSet* _tmp41_;
						ValaHashMap* _tmp42_;
						ValaVariable* _tmp43_;
						ValaSet* _tmp44_;
						_tmp39_ = g_direct_hash;
						_tmp40_ = g_direct_equal;
						_tmp41_ = vala_hash_set_new (VALA_TYPE_BASIC_BLOCK, (GBoxedCopyFunc) vala_basic_block_ref, (GDestroyNotify) vala_basic_block_unref, _tmp39_, _tmp40_);
						_vala_iterable_unref0 (block_set);
						block_set = (ValaSet*) _tmp41_;
						_tmp42_ = map;
						_tmp43_ = variable;
						_tmp44_ = block_set;
						vala_map_set ((ValaMap*) _tmp42_, _tmp43_, _tmp44_);
					}
					_tmp45_ = block_set;
					_tmp46_ = block;
					vala_collection_add ((ValaCollection*) _tmp45_, _tmp46_);
					_vala_iterable_unref0 (block_set);
					_vala_code_node_unref0 (variable);
				}
				_vala_iterable_unref0 (_variable_list);
			}
			_vala_iterable_unref0 (defined_variables);
			_vala_basic_block_unref0 (block);
		}
		_vala_iterable_unref0 (_block_list);
	}
	result = (ValaMap*) map;
	return result;
}

static void
vala_flow_analyzer_insert_phi_functions (ValaFlowAnalyzer* self,
                                         ValaList* block_list,
                                         ValaBasicBlock* entry_block)
{
	ValaMap* assign = NULL;
	ValaMap* _tmp0_;
	gint counter = 0;
	ValaArrayList* work_list = NULL;
	GEqualFunc _tmp1_;
	ValaArrayList* _tmp2_;
	ValaHashMap* added = NULL;
	GHashFunc _tmp3_;
	GEqualFunc _tmp4_;
	GEqualFunc _tmp5_;
	ValaHashMap* _tmp6_;
	ValaHashMap* phi = NULL;
	GHashFunc _tmp7_;
	GEqualFunc _tmp8_;
	GEqualFunc _tmp9_;
	ValaHashMap* _tmp10_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (block_list != NULL);
	g_return_if_fail (entry_block != NULL);
	_tmp0_ = vala_flow_analyzer_get_assignment_map (self, block_list, entry_block);
	assign = _tmp0_;
	counter = 0;
	_tmp1_ = g_direct_equal;
	_tmp2_ = vala_array_list_new (VALA_TYPE_BASIC_BLOCK, (GBoxedCopyFunc) vala_basic_block_ref, (GDestroyNotify) vala_basic_block_unref, _tmp1_);
	work_list = _tmp2_;
	_tmp3_ = g_direct_hash;
	_tmp4_ = g_direct_equal;
	_tmp5_ = g_direct_equal;
	_tmp6_ = vala_hash_map_new (VALA_TYPE_BASIC_BLOCK, (GBoxedCopyFunc) vala_basic_block_ref, (GDestroyNotify) vala_basic_block_unref, G_TYPE_INT, NULL, NULL, _tmp3_, _tmp4_, _tmp5_);
	added = _tmp6_;
	_tmp7_ = g_direct_hash;
	_tmp8_ = g_direct_equal;
	_tmp9_ = g_direct_equal;
	_tmp10_ = vala_hash_map_new (VALA_TYPE_BASIC_BLOCK, (GBoxedCopyFunc) vala_basic_block_ref, (GDestroyNotify) vala_basic_block_unref, G_TYPE_INT, NULL, NULL, _tmp7_, _tmp8_, _tmp9_);
	phi = _tmp10_;
	{
		ValaList* _block_list = NULL;
		ValaList* _tmp11_;
		gint _block_size = 0;
		ValaList* _tmp12_;
		gint _tmp13_;
		gint _tmp14_;
		gint _block_index = 0;
		_tmp11_ = _vala_iterable_ref0 (block_list);
		_block_list = _tmp11_;
		_tmp12_ = _block_list;
		_tmp13_ = vala_collection_get_size ((ValaCollection*) _tmp12_);
		_tmp14_ = _tmp13_;
		_block_size = _tmp14_;
		_block_index = -1;
		while (TRUE) {
			gint _tmp15_;
			gint _tmp16_;
			ValaBasicBlock* block = NULL;
			ValaList* _tmp17_;
			gpointer _tmp18_;
			ValaHashMap* _tmp19_;
			ValaBasicBlock* _tmp20_;
			ValaHashMap* _tmp21_;
			ValaBasicBlock* _tmp22_;
			_block_index = _block_index + 1;
			_tmp15_ = _block_index;
			_tmp16_ = _block_size;
			if (!(_tmp15_ < _tmp16_)) {
				break;
			}
			_tmp17_ = _block_list;
			_tmp18_ = vala_list_get (_tmp17_, _block_index);
			block = (ValaBasicBlock*) _tmp18_;
			_tmp19_ = added;
			_tmp20_ = block;
			vala_map_set ((ValaMap*) _tmp19_, _tmp20_, (gpointer) ((gintptr) 0));
			_tmp21_ = phi;
			_tmp22_ = block;
			vala_map_set ((ValaMap*) _tmp21_, _tmp22_, (gpointer) ((gintptr) 0));
			_vala_basic_block_unref0 (block);
		}
		_vala_iterable_unref0 (_block_list);
	}
	{
		ValaIterator* _variable_it = NULL;
		ValaMap* _tmp23_;
		ValaSet* _tmp24_;
		ValaSet* _tmp25_;
		ValaIterator* _tmp26_;
		ValaIterator* _tmp27_;
		_tmp23_ = assign;
		_tmp24_ = vala_map_get_keys (_tmp23_);
		_tmp25_ = _tmp24_;
		_tmp26_ = vala_iterable_iterator ((ValaIterable*) _tmp25_);
		_tmp27_ = _tmp26_;
		_vala_iterable_unref0 (_tmp25_);
		_variable_it = _tmp27_;
		while (TRUE) {
			ValaIterator* _tmp28_;
			ValaVariable* variable = NULL;
			ValaIterator* _tmp29_;
			gpointer _tmp30_;
			gint _tmp31_;
			_tmp28_ = _variable_it;
			if (!vala_iterator_next (_tmp28_)) {
				break;
			}
			_tmp29_ = _variable_it;
			_tmp30_ = vala_iterator_get (_tmp29_);
			variable = (ValaVariable*) _tmp30_;
			_tmp31_ = counter;
			counter = _tmp31_ + 1;
			{
				ValaIterator* _block_it = NULL;
				ValaMap* _tmp32_;
				ValaVariable* _tmp33_;
				gpointer _tmp34_;
				ValaSet* _tmp35_;
				ValaIterator* _tmp36_;
				ValaIterator* _tmp37_;
				_tmp32_ = assign;
				_tmp33_ = variable;
				_tmp34_ = vala_map_get (_tmp32_, _tmp33_);
				_tmp35_ = (ValaSet*) _tmp34_;
				_tmp36_ = vala_iterable_iterator ((ValaIterable*) _tmp35_);
				_tmp37_ = _tmp36_;
				_vala_iterable_unref0 (_tmp35_);
				_block_it = _tmp37_;
				while (TRUE) {
					ValaIterator* _tmp38_;
					ValaBasicBlock* block = NULL;
					ValaIterator* _tmp39_;
					gpointer _tmp40_;
					ValaArrayList* _tmp41_;
					ValaBasicBlock* _tmp42_;
					ValaHashMap* _tmp43_;
					ValaBasicBlock* _tmp44_;
					_tmp38_ = _block_it;
					if (!vala_iterator_next (_tmp38_)) {
						break;
					}
					_tmp39_ = _block_it;
					_tmp40_ = vala_iterator_get (_tmp39_);
					block = (ValaBasicBlock*) _tmp40_;
					_tmp41_ = work_list;
					_tmp42_ = block;
					vala_collection_add ((ValaCollection*) _tmp41_, _tmp42_);
					_tmp43_ = added;
					_tmp44_ = block;
					vala_map_set ((ValaMap*) _tmp43_, _tmp44_, (gpointer) ((gintptr) counter));
					_vala_basic_block_unref0 (block);
				}
				_vala_iterator_unref0 (_block_it);
			}
			while (TRUE) {
				ValaArrayList* _tmp45_;
				gint _tmp46_;
				gint _tmp47_;
				ValaBasicBlock* block = NULL;
				ValaArrayList* _tmp48_;
				gpointer _tmp49_;
				_tmp45_ = work_list;
				_tmp46_ = vala_collection_get_size ((ValaCollection*) _tmp45_);
				_tmp47_ = _tmp46_;
				if (!(_tmp47_ > 0)) {
					break;
				}
				_tmp48_ = work_list;
				_tmp49_ = vala_list_remove_at ((ValaList*) _tmp48_, 0);
				block = (ValaBasicBlock*) _tmp49_;
				{
					ValaIterator* _frontier_it = NULL;
					ValaBasicBlock* _tmp50_;
					ValaSet* _tmp51_;
					ValaIterator* _tmp52_;
					_tmp50_ = block;
					_tmp51_ = vala_basic_block_get_dominator_frontier (_tmp50_);
					_tmp52_ = vala_iterable_iterator ((ValaIterable*) _tmp51_);
					_frontier_it = _tmp52_;
					while (TRUE) {
						ValaIterator* _tmp53_;
						ValaBasicBlock* frontier = NULL;
						ValaIterator* _tmp54_;
						gpointer _tmp55_;
						ValaBasicBlock* _tmp56_;
						gint blockPhi = 0;
						ValaHashMap* _tmp57_;
						ValaBasicBlock* _tmp58_;
						gpointer _tmp59_;
						_tmp53_ = _frontier_it;
						if (!vala_iterator_next (_tmp53_)) {
							break;
						}
						_tmp54_ = _frontier_it;
						_tmp55_ = vala_iterator_get (_tmp54_);
						_tmp56_ = _vala_basic_block_ref0 ((ValaBasicBlock*) _tmp55_);
						frontier = _tmp56_;
						_tmp57_ = phi;
						_tmp58_ = frontier;
						_tmp59_ = vala_map_get ((ValaMap*) _tmp57_, _tmp58_);
						blockPhi = (gint) ((gintptr) _tmp59_);
						if (blockPhi < counter) {
							ValaBasicBlock* _tmp60_;
							ValaVariable* _tmp61_;
							ValaBasicBlock* _tmp62_;
							ValaList* _tmp63_;
							gint _tmp64_;
							gint _tmp65_;
							ValaPhiFunction* _tmp66_;
							ValaPhiFunction* _tmp67_;
							ValaHashMap* _tmp68_;
							ValaBasicBlock* _tmp69_;
							gint block_added = 0;
							ValaHashMap* _tmp70_;
							ValaBasicBlock* _tmp71_;
							gpointer _tmp72_;
							_tmp60_ = frontier;
							_tmp61_ = variable;
							_tmp62_ = frontier;
							_tmp63_ = vala_basic_block_get_predecessors (_tmp62_);
							_tmp64_ = vala_collection_get_size ((ValaCollection*) _tmp63_);
							_tmp65_ = _tmp64_;
							_tmp66_ = vala_phi_function_new (_tmp61_, _tmp65_);
							_tmp67_ = _tmp66_;
							vala_basic_block_add_phi_function (_tmp60_, _tmp67_);
							_vala_phi_function_unref0 (_tmp67_);
							_tmp68_ = phi;
							_tmp69_ = frontier;
							vala_map_set ((ValaMap*) _tmp68_, _tmp69_, (gpointer) ((gintptr) counter));
							_tmp70_ = added;
							_tmp71_ = frontier;
							_tmp72_ = vala_map_get ((ValaMap*) _tmp70_, _tmp71_);
							block_added = (gint) ((gintptr) _tmp72_);
							if (block_added < counter) {
								ValaHashMap* _tmp73_;
								ValaBasicBlock* _tmp74_;
								ValaArrayList* _tmp75_;
								ValaBasicBlock* _tmp76_;
								_tmp73_ = added;
								_tmp74_ = frontier;
								vala_map_set ((ValaMap*) _tmp73_, _tmp74_, (gpointer) ((gintptr) counter));
								_tmp75_ = work_list;
								_tmp76_ = frontier;
								vala_collection_add ((ValaCollection*) _tmp75_, _tmp76_);
							}
						}
						_vala_basic_block_unref0 (frontier);
					}
					_vala_iterator_unref0 (_frontier_it);
				}
				_vala_basic_block_unref0 (block);
			}
			_vala_code_node_unref0 (variable);
		}
		_vala_iterator_unref0 (_variable_it);
	}
	_vala_map_unref0 (phi);
	_vala_map_unref0 (added);
	_vala_iterable_unref0 (work_list);
	_vala_map_unref0 (assign);
}

static void
vala_flow_analyzer_check_variables (ValaFlowAnalyzer* self,
                                    ValaBasicBlock* entry_block)
{
	GHashFunc _tmp0_;
	GEqualFunc _tmp1_;
	GEqualFunc _tmp2_;
	ValaHashMap* _tmp3_;
	GHashFunc _tmp4_;
	GEqualFunc _tmp5_;
	ValaHashSet* _tmp6_;
	GHashFunc _tmp7_;
	GEqualFunc _tmp8_;
	GEqualFunc _tmp9_;
	ValaHashMap* _tmp10_;
	ValaArrayList* used_vars_queue = NULL;
	GEqualFunc _tmp11_;
	ValaArrayList* _tmp12_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (entry_block != NULL);
	_tmp0_ = g_direct_hash;
	_tmp1_ = g_direct_equal;
	_tmp2_ = g_direct_equal;
	_tmp3_ = vala_hash_map_new (VALA_TYPE_SYMBOL, (GBoxedCopyFunc) vala_code_node_ref, (GDestroyNotify) vala_code_node_unref, VALA_TYPE_LIST, (GBoxedCopyFunc) vala_iterable_ref, (GDestroyNotify) vala_iterable_unref, _tmp0_, _tmp1_, _tmp2_);
	_vala_map_unref0 (self->priv->var_map);
	self->priv->var_map = (ValaMap*) _tmp3_;
	_tmp4_ = g_direct_hash;
	_tmp5_ = g_direct_equal;
	_tmp6_ = vala_hash_set_new (VALA_TYPE_VARIABLE, (GBoxedCopyFunc) vala_code_node_ref, (GDestroyNotify) vala_code_node_unref, _tmp4_, _tmp5_);
	_vala_iterable_unref0 (self->priv->used_vars);
	self->priv->used_vars = (ValaSet*) _tmp6_;
	_tmp7_ = g_direct_hash;
	_tmp8_ = g_direct_equal;
	_tmp9_ = g_direct_equal;
	_tmp10_ = vala_hash_map_new (VALA_TYPE_VARIABLE, (GBoxedCopyFunc) vala_code_node_ref, (GDestroyNotify) vala_code_node_unref, VALA_TYPE_PHI_FUNCTION, (GBoxedCopyFunc) vala_phi_function_ref, (GDestroyNotify) vala_phi_function_unref, _tmp7_, _tmp8_, _tmp9_);
	_vala_map_unref0 (self->priv->phi_functions);
	self->priv->phi_functions = (ValaMap*) _tmp10_;
	vala_flow_analyzer_check_block_variables (self, entry_block);
	_tmp11_ = g_direct_equal;
	_tmp12_ = vala_array_list_new (VALA_TYPE_VARIABLE, (GBoxedCopyFunc) vala_code_node_ref, (GDestroyNotify) vala_code_node_unref, _tmp11_);
	used_vars_queue = _tmp12_;
	{
		ValaIterator* _variable_it = NULL;
		ValaSet* _tmp13_;
		ValaIterator* _tmp14_;
		_tmp13_ = self->priv->used_vars;
		_tmp14_ = vala_iterable_iterator ((ValaIterable*) _tmp13_);
		_variable_it = _tmp14_;
		while (TRUE) {
			ValaIterator* _tmp15_;
			ValaVariable* variable = NULL;
			ValaIterator* _tmp16_;
			gpointer _tmp17_;
			ValaArrayList* _tmp18_;
			ValaVariable* _tmp19_;
			_tmp15_ = _variable_it;
			if (!vala_iterator_next (_tmp15_)) {
				break;
			}
			_tmp16_ = _variable_it;
			_tmp17_ = vala_iterator_get (_tmp16_);
			variable = (ValaVariable*) _tmp17_;
			_tmp18_ = used_vars_queue;
			_tmp19_ = variable;
			vala_collection_add ((ValaCollection*) _tmp18_, _tmp19_);
			_vala_code_node_unref0 (variable);
		}
		_vala_iterator_unref0 (_variable_it);
	}
	while (TRUE) {
		ValaArrayList* _tmp20_;
		gint _tmp21_;
		gint _tmp22_;
		ValaVariable* used_var = NULL;
		ValaArrayList* _tmp23_;
		gpointer _tmp24_;
		ValaPhiFunction* phi = NULL;
		ValaMap* _tmp25_;
		ValaVariable* _tmp26_;
		gpointer _tmp27_;
		ValaPhiFunction* _tmp28_;
		_tmp20_ = used_vars_queue;
		_tmp21_ = vala_collection_get_size ((ValaCollection*) _tmp20_);
		_tmp22_ = _tmp21_;
		if (!(_tmp22_ > 0)) {
			break;
		}
		_tmp23_ = used_vars_queue;
		_tmp24_ = vala_list_remove_at ((ValaList*) _tmp23_, 0);
		used_var = (ValaVariable*) _tmp24_;
		_tmp25_ = self->priv->phi_functions;
		_tmp26_ = used_var;
		_tmp27_ = vala_map_get (_tmp25_, _tmp26_);
		phi = (ValaPhiFunction*) _tmp27_;
		_tmp28_ = phi;
		if (_tmp28_ != NULL) {
			{
				ValaList* _variable_list = NULL;
				ValaPhiFunction* _tmp29_;
				ValaList* _tmp30_;
				ValaList* _tmp31_;
				ValaList* _tmp32_;
				gint _variable_size = 0;
				ValaList* _tmp33_;
				gint _tmp34_;
				gint _tmp35_;
				gint _variable_index = 0;
				_tmp29_ = phi;
				_tmp30_ = vala_phi_function_get_operands (_tmp29_);
				_tmp31_ = _tmp30_;
				_tmp32_ = _vala_iterable_ref0 (_tmp31_);
				_variable_list = _tmp32_;
				_tmp33_ = _variable_list;
				_tmp34_ = vala_collection_get_size ((ValaCollection*) _tmp33_);
				_tmp35_ = _tmp34_;
				_variable_size = _tmp35_;
				_variable_index = -1;
				while (TRUE) {
					gint _tmp36_;
					gint _tmp37_;
					ValaVariable* variable = NULL;
					ValaList* _tmp38_;
					gpointer _tmp39_;
					ValaVariable* _tmp40_;
					ValaSet* _tmp58_;
					ValaVariable* _tmp59_;
					_variable_index = _variable_index + 1;
					_tmp36_ = _variable_index;
					_tmp37_ = _variable_size;
					if (!(_tmp36_ < _tmp37_)) {
						break;
					}
					_tmp38_ = _variable_list;
					_tmp39_ = vala_list_get (_tmp38_, _variable_index);
					variable = (ValaVariable*) _tmp39_;
					_tmp40_ = variable;
					if (_tmp40_ == NULL) {
						ValaVariable* _tmp41_;
						_tmp41_ = used_var;
						if (VALA_IS_LOCAL_VARIABLE (_tmp41_)) {
							ValaVariable* _tmp42_;
							ValaSourceReference* _tmp43_;
							ValaSourceReference* _tmp44_;
							ValaVariable* _tmp45_;
							const gchar* _tmp46_;
							const gchar* _tmp47_;
							gchar* _tmp48_;
							gchar* _tmp49_;
							_tmp42_ = used_var;
							_tmp43_ = vala_code_node_get_source_reference ((ValaCodeNode*) _tmp42_);
							_tmp44_ = _tmp43_;
							_tmp45_ = used_var;
							_tmp46_ = vala_symbol_get_name ((ValaSymbol*) _tmp45_);
							_tmp47_ = _tmp46_;
							_tmp48_ = g_strdup_printf ("use of possibly unassigned local variable `%s'", _tmp47_);
							_tmp49_ = _tmp48_;
							vala_report_error (_tmp44_, _tmp49_);
							_g_free0 (_tmp49_);
						} else {
							ValaVariable* _tmp50_;
							ValaSourceReference* _tmp51_;
							ValaSourceReference* _tmp52_;
							ValaVariable* _tmp53_;
							const gchar* _tmp54_;
							const gchar* _tmp55_;
							gchar* _tmp56_;
							gchar* _tmp57_;
							_tmp50_ = used_var;
							_tmp51_ = vala_code_node_get_source_reference ((ValaCodeNode*) _tmp50_);
							_tmp52_ = _tmp51_;
							_tmp53_ = used_var;
							_tmp54_ = vala_symbol_get_name ((ValaSymbol*) _tmp53_);
							_tmp55_ = _tmp54_;
							_tmp56_ = g_strdup_printf ("use of possibly unassigned parameter `%s'", _tmp55_);
							_tmp57_ = _tmp56_;
							vala_report_warning (_tmp52_, _tmp57_);
							_g_free0 (_tmp57_);
						}
						_vala_code_node_unref0 (variable);
						continue;
					}
					_tmp58_ = self->priv->used_vars;
					_tmp59_ = variable;
					if (!vala_collection_contains ((ValaCollection*) _tmp58_, _tmp59_)) {
						ValaVariable* _tmp60_;
						ValaVariable* _tmp61_;
						ValaSourceReference* _tmp62_;
						ValaSourceReference* _tmp63_;
						ValaSet* _tmp64_;
						ValaVariable* _tmp65_;
						ValaArrayList* _tmp66_;
						ValaVariable* _tmp67_;
						_tmp60_ = variable;
						_tmp61_ = used_var;
						_tmp62_ = vala_code_node_get_source_reference ((ValaCodeNode*) _tmp61_);
						_tmp63_ = _tmp62_;
						vala_code_node_set_source_reference ((ValaCodeNode*) _tmp60_, _tmp63_);
						_tmp64_ = self->priv->used_vars;
						_tmp65_ = variable;
						vala_collection_add ((ValaCollection*) _tmp64_, _tmp65_);
						_tmp66_ = used_vars_queue;
						_tmp67_ = variable;
						vala_collection_add ((ValaCollection*) _tmp66_, _tmp67_);
					}
					_vala_code_node_unref0 (variable);
				}
				_vala_iterable_unref0 (_variable_list);
			}
		}
		_vala_phi_function_unref0 (phi);
		_vala_code_node_unref0 (used_var);
	}
	_vala_map_unref0 (self->priv->phi_functions);
	self->priv->phi_functions = NULL;
	_vala_iterable_unref0 (self->priv->used_vars);
	self->priv->used_vars = NULL;
	_vala_map_unref0 (self->priv->var_map);
	self->priv->var_map = NULL;
	_vala_iterable_unref0 (used_vars_queue);
}

static void
vala_flow_analyzer_check_block_variables (ValaFlowAnalyzer* self,
                                          ValaBasicBlock* block)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (block != NULL);
	{
		ValaIterator* _phi_it = NULL;
		ValaSet* _tmp0_;
		ValaIterator* _tmp1_;
		_tmp0_ = vala_basic_block_get_phi_functions (block);
		_tmp1_ = vala_iterable_iterator ((ValaIterable*) _tmp0_);
		_phi_it = _tmp1_;
		while (TRUE) {
			ValaIterator* _tmp2_;
			ValaPhiFunction* phi = NULL;
			ValaIterator* _tmp3_;
			gpointer _tmp4_;
			ValaVariable* versioned_var = NULL;
			ValaMap* _tmp5_;
			ValaPhiFunction* _tmp6_;
			ValaVariable* _tmp7_;
			ValaVariable* _tmp8_;
			ValaVariable* _tmp9_;
			ValaMap* _tmp10_;
			ValaVariable* _tmp11_;
			ValaPhiFunction* _tmp12_;
			_tmp2_ = _phi_it;
			if (!vala_iterator_next (_tmp2_)) {
				break;
			}
			_tmp3_ = _phi_it;
			_tmp4_ = vala_iterator_get (_tmp3_);
			phi = (ValaPhiFunction*) _tmp4_;
			_tmp5_ = self->priv->var_map;
			_tmp6_ = phi;
			_tmp7_ = vala_phi_function_get_original_variable (_tmp6_);
			_tmp8_ = _tmp7_;
			_tmp9_ = vala_flow_analyzer_process_assignment (self, _tmp5_, _tmp8_);
			versioned_var = _tmp9_;
			_tmp10_ = self->priv->phi_functions;
			_tmp11_ = versioned_var;
			_tmp12_ = phi;
			vala_map_set (_tmp10_, _tmp11_, _tmp12_);
			_vala_code_node_unref0 (versioned_var);
			_vala_phi_function_unref0 (phi);
		}
		_vala_iterator_unref0 (_phi_it);
	}
	{
		ValaList* _node_list = NULL;
		ValaList* _tmp13_;
		ValaList* _tmp14_;
		gint _node_size = 0;
		ValaList* _tmp15_;
		gint _tmp16_;
		gint _tmp17_;
		gint _node_index = 0;
		_tmp13_ = vala_basic_block_get_nodes (block);
		_tmp14_ = _vala_iterable_ref0 (_tmp13_);
		_node_list = _tmp14_;
		_tmp15_ = _node_list;
		_tmp16_ = vala_collection_get_size ((ValaCollection*) _tmp15_);
		_tmp17_ = _tmp16_;
		_node_size = _tmp17_;
		_node_index = -1;
		while (TRUE) {
			gint _tmp18_;
			gint _tmp19_;
			ValaCodeNode* node = NULL;
			ValaList* _tmp20_;
			gpointer _tmp21_;
			ValaArrayList* used_variables = NULL;
			GEqualFunc _tmp22_;
			ValaArrayList* _tmp23_;
			ValaCodeNode* _tmp24_;
			ValaArrayList* _tmp25_;
			ValaArrayList* defined_variables = NULL;
			GEqualFunc _tmp73_;
			ValaArrayList* _tmp74_;
			ValaCodeNode* _tmp75_;
			ValaArrayList* _tmp76_;
			_node_index = _node_index + 1;
			_tmp18_ = _node_index;
			_tmp19_ = _node_size;
			if (!(_tmp18_ < _tmp19_)) {
				break;
			}
			_tmp20_ = _node_list;
			_tmp21_ = vala_list_get (_tmp20_, _node_index);
			node = (ValaCodeNode*) _tmp21_;
			_tmp22_ = g_direct_equal;
			_tmp23_ = vala_array_list_new (VALA_TYPE_VARIABLE, (GBoxedCopyFunc) vala_code_node_ref, (GDestroyNotify) vala_code_node_unref, _tmp22_);
			used_variables = _tmp23_;
			_tmp24_ = node;
			_tmp25_ = used_variables;
			vala_code_node_get_used_variables (_tmp24_, (ValaCollection*) _tmp25_);
			{
				ValaArrayList* _var_symbol_list = NULL;
				ValaArrayList* _tmp26_;
				ValaArrayList* _tmp27_;
				gint _var_symbol_size = 0;
				ValaArrayList* _tmp28_;
				gint _tmp29_;
				gint _tmp30_;
				gint _var_symbol_index = 0;
				_tmp26_ = used_variables;
				_tmp27_ = _vala_iterable_ref0 (_tmp26_);
				_var_symbol_list = _tmp27_;
				_tmp28_ = _var_symbol_list;
				_tmp29_ = vala_collection_get_size ((ValaCollection*) _tmp28_);
				_tmp30_ = _tmp29_;
				_var_symbol_size = _tmp30_;
				_var_symbol_index = -1;
				while (TRUE) {
					gint _tmp31_;
					gint _tmp32_;
					ValaVariable* var_symbol = NULL;
					ValaArrayList* _tmp33_;
					gpointer _tmp34_;
					ValaList* variable_stack = NULL;
					ValaMap* _tmp35_;
					ValaVariable* _tmp36_;
					gpointer _tmp37_;
					gboolean _tmp38_ = FALSE;
					ValaList* _tmp39_;
					ValaVariable* versioned_variable = NULL;
					ValaList* _tmp60_;
					ValaList* _tmp61_;
					gint _tmp62_;
					gint _tmp63_;
					gpointer _tmp64_;
					ValaSet* _tmp65_;
					ValaVariable* _tmp66_;
					ValaSet* _tmp71_;
					ValaVariable* _tmp72_;
					_var_symbol_index = _var_symbol_index + 1;
					_tmp31_ = _var_symbol_index;
					_tmp32_ = _var_symbol_size;
					if (!(_tmp31_ < _tmp32_)) {
						break;
					}
					_tmp33_ = _var_symbol_list;
					_tmp34_ = vala_list_get ((ValaList*) _tmp33_, _var_symbol_index);
					var_symbol = (ValaVariable*) _tmp34_;
					_tmp35_ = self->priv->var_map;
					_tmp36_ = var_symbol;
					_tmp37_ = vala_map_get (_tmp35_, (ValaSymbol*) _tmp36_);
					variable_stack = (ValaList*) _tmp37_;
					_tmp39_ = variable_stack;
					if (_tmp39_ == NULL) {
						_tmp38_ = TRUE;
					} else {
						ValaList* _tmp40_;
						gint _tmp41_;
						gint _tmp42_;
						_tmp40_ = variable_stack;
						_tmp41_ = vala_collection_get_size ((ValaCollection*) _tmp40_);
						_tmp42_ = _tmp41_;
						_tmp38_ = _tmp42_ == 0;
					}
					if (_tmp38_) {
						ValaVariable* _tmp43_;
						_tmp43_ = var_symbol;
						if (VALA_IS_LOCAL_VARIABLE (_tmp43_)) {
							ValaCodeNode* _tmp44_;
							ValaSourceReference* _tmp45_;
							ValaSourceReference* _tmp46_;
							ValaVariable* _tmp47_;
							const gchar* _tmp48_;
							const gchar* _tmp49_;
							gchar* _tmp50_;
							gchar* _tmp51_;
							_tmp44_ = node;
							_tmp45_ = vala_code_node_get_source_reference (_tmp44_);
							_tmp46_ = _tmp45_;
							_tmp47_ = var_symbol;
							_tmp48_ = vala_symbol_get_name ((ValaSymbol*) _tmp47_);
							_tmp49_ = _tmp48_;
							_tmp50_ = g_strdup_printf ("use of possibly unassigned local variable `%s'", _tmp49_);
							_tmp51_ = _tmp50_;
							vala_report_error (_tmp46_, _tmp51_);
							_g_free0 (_tmp51_);
						} else {
							ValaCodeNode* _tmp52_;
							ValaSourceReference* _tmp53_;
							ValaSourceReference* _tmp54_;
							ValaVariable* _tmp55_;
							const gchar* _tmp56_;
							const gchar* _tmp57_;
							gchar* _tmp58_;
							gchar* _tmp59_;
							_tmp52_ = node;
							_tmp53_ = vala_code_node_get_source_reference (_tmp52_);
							_tmp54_ = _tmp53_;
							_tmp55_ = var_symbol;
							_tmp56_ = vala_symbol_get_name ((ValaSymbol*) _tmp55_);
							_tmp57_ = _tmp56_;
							_tmp58_ = g_strdup_printf ("use of possibly unassigned parameter `%s'", _tmp57_);
							_tmp59_ = _tmp58_;
							vala_report_warning (_tmp54_, _tmp59_);
							_g_free0 (_tmp59_);
						}
						_vala_iterable_unref0 (variable_stack);
						_vala_code_node_unref0 (var_symbol);
						continue;
					}
					_tmp60_ = variable_stack;
					_tmp61_ = variable_stack;
					_tmp62_ = vala_collection_get_size ((ValaCollection*) _tmp61_);
					_tmp63_ = _tmp62_;
					_tmp64_ = vala_list_get (_tmp60_, _tmp63_ - 1);
					versioned_variable = (ValaVariable*) _tmp64_;
					_tmp65_ = self->priv->used_vars;
					_tmp66_ = versioned_variable;
					if (!vala_collection_contains ((ValaCollection*) _tmp65_, _tmp66_)) {
						ValaVariable* _tmp67_;
						ValaCodeNode* _tmp68_;
						ValaSourceReference* _tmp69_;
						ValaSourceReference* _tmp70_;
						_tmp67_ = versioned_variable;
						_tmp68_ = node;
						_tmp69_ = vala_code_node_get_source_reference (_tmp68_);
						_tmp70_ = _tmp69_;
						vala_code_node_set_source_reference ((ValaCodeNode*) _tmp67_, _tmp70_);
					}
					_tmp71_ = self->priv->used_vars;
					_tmp72_ = versioned_variable;
					vala_collection_add ((ValaCollection*) _tmp71_, _tmp72_);
					_vala_code_node_unref0 (versioned_variable);
					_vala_iterable_unref0 (variable_stack);
					_vala_code_node_unref0 (var_symbol);
				}
				_vala_iterable_unref0 (_var_symbol_list);
			}
			_tmp73_ = g_direct_equal;
			_tmp74_ = vala_array_list_new (VALA_TYPE_VARIABLE, (GBoxedCopyFunc) vala_code_node_ref, (GDestroyNotify) vala_code_node_unref, _tmp73_);
			defined_variables = _tmp74_;
			_tmp75_ = node;
			_tmp76_ = defined_variables;
			vala_code_node_get_defined_variables (_tmp75_, (ValaCollection*) _tmp76_);
			{
				ValaArrayList* _variable_list = NULL;
				ValaArrayList* _tmp77_;
				ValaArrayList* _tmp78_;
				gint _variable_size = 0;
				ValaArrayList* _tmp79_;
				gint _tmp80_;
				gint _tmp81_;
				gint _variable_index = 0;
				_tmp77_ = defined_variables;
				_tmp78_ = _vala_iterable_ref0 (_tmp77_);
				_variable_list = _tmp78_;
				_tmp79_ = _variable_list;
				_tmp80_ = vala_collection_get_size ((ValaCollection*) _tmp79_);
				_tmp81_ = _tmp80_;
				_variable_size = _tmp81_;
				_variable_index = -1;
				while (TRUE) {
					gint _tmp82_;
					gint _tmp83_;
					ValaVariable* variable = NULL;
					ValaArrayList* _tmp84_;
					gpointer _tmp85_;
					ValaMap* _tmp86_;
					ValaVariable* _tmp87_;
					ValaVariable* _tmp88_;
					ValaVariable* _tmp89_;
					_variable_index = _variable_index + 1;
					_tmp82_ = _variable_index;
					_tmp83_ = _variable_size;
					if (!(_tmp82_ < _tmp83_)) {
						break;
					}
					_tmp84_ = _variable_list;
					_tmp85_ = vala_list_get ((ValaList*) _tmp84_, _variable_index);
					variable = (ValaVariable*) _tmp85_;
					_tmp86_ = self->priv->var_map;
					_tmp87_ = variable;
					_tmp88_ = vala_flow_analyzer_process_assignment (self, _tmp86_, _tmp87_);
					_tmp89_ = _tmp88_;
					_vala_code_node_unref0 (_tmp89_);
					_vala_code_node_unref0 (variable);
				}
				_vala_iterable_unref0 (_variable_list);
			}
			_vala_iterable_unref0 (defined_variables);
			_vala_iterable_unref0 (used_variables);
			_vala_code_node_unref0 (node);
		}
		_vala_iterable_unref0 (_node_list);
	}
	{
		ValaList* _succ_list = NULL;
		ValaList* _tmp90_;
		ValaList* _tmp91_;
		gint _succ_size = 0;
		ValaList* _tmp92_;
		gint _tmp93_;
		gint _tmp94_;
		gint _succ_index = 0;
		_tmp90_ = vala_basic_block_get_successors (block);
		_tmp91_ = _vala_iterable_ref0 (_tmp90_);
		_succ_list = _tmp91_;
		_tmp92_ = _succ_list;
		_tmp93_ = vala_collection_get_size ((ValaCollection*) _tmp92_);
		_tmp94_ = _tmp93_;
		_succ_size = _tmp94_;
		_succ_index = -1;
		while (TRUE) {
			gint _tmp95_;
			gint _tmp96_;
			ValaBasicBlock* succ = NULL;
			ValaList* _tmp97_;
			gpointer _tmp98_;
			gint j = 0;
			_succ_index = _succ_index + 1;
			_tmp95_ = _succ_index;
			_tmp96_ = _succ_size;
			if (!(_tmp95_ < _tmp96_)) {
				break;
			}
			_tmp97_ = _succ_list;
			_tmp98_ = vala_list_get (_tmp97_, _succ_index);
			succ = (ValaBasicBlock*) _tmp98_;
			j = 0;
			{
				ValaList* _pred_list = NULL;
				ValaBasicBlock* _tmp99_;
				ValaList* _tmp100_;
				ValaList* _tmp101_;
				gint _pred_size = 0;
				ValaList* _tmp102_;
				gint _tmp103_;
				gint _tmp104_;
				gint _pred_index = 0;
				_tmp99_ = succ;
				_tmp100_ = vala_basic_block_get_predecessors (_tmp99_);
				_tmp101_ = _vala_iterable_ref0 (_tmp100_);
				_pred_list = _tmp101_;
				_tmp102_ = _pred_list;
				_tmp103_ = vala_collection_get_size ((ValaCollection*) _tmp102_);
				_tmp104_ = _tmp103_;
				_pred_size = _tmp104_;
				_pred_index = -1;
				while (TRUE) {
					gint _tmp105_;
					gint _tmp106_;
					ValaBasicBlock* pred = NULL;
					ValaList* _tmp107_;
					gpointer _tmp108_;
					ValaBasicBlock* _tmp109_;
					gint _tmp110_;
					_pred_index = _pred_index + 1;
					_tmp105_ = _pred_index;
					_tmp106_ = _pred_size;
					if (!(_tmp105_ < _tmp106_)) {
						break;
					}
					_tmp107_ = _pred_list;
					_tmp108_ = vala_list_get (_tmp107_, _pred_index);
					pred = (ValaBasicBlock*) _tmp108_;
					_tmp109_ = pred;
					if (_tmp109_ == block) {
						break;
					}
					_tmp110_ = j;
					j = _tmp110_ + 1;
				}
				_vala_iterable_unref0 (_pred_list);
			}
			{
				ValaIterator* _phi_it = NULL;
				ValaBasicBlock* _tmp111_;
				ValaSet* _tmp112_;
				ValaIterator* _tmp113_;
				_tmp111_ = succ;
				_tmp112_ = vala_basic_block_get_phi_functions (_tmp111_);
				_tmp113_ = vala_iterable_iterator ((ValaIterable*) _tmp112_);
				_phi_it = _tmp113_;
				while (TRUE) {
					ValaIterator* _tmp114_;
					ValaPhiFunction* phi = NULL;
					ValaIterator* _tmp115_;
					gpointer _tmp116_;
					ValaList* variable_stack = NULL;
					ValaMap* _tmp117_;
					ValaPhiFunction* _tmp118_;
					ValaVariable* _tmp119_;
					ValaVariable* _tmp120_;
					gpointer _tmp121_;
					gboolean _tmp122_ = FALSE;
					ValaList* _tmp123_;
					_tmp114_ = _phi_it;
					if (!vala_iterator_next (_tmp114_)) {
						break;
					}
					_tmp115_ = _phi_it;
					_tmp116_ = vala_iterator_get (_tmp115_);
					phi = (ValaPhiFunction*) _tmp116_;
					_tmp117_ = self->priv->var_map;
					_tmp118_ = phi;
					_tmp119_ = vala_phi_function_get_original_variable (_tmp118_);
					_tmp120_ = _tmp119_;
					_tmp121_ = vala_map_get (_tmp117_, (ValaSymbol*) _tmp120_);
					variable_stack = (ValaList*) _tmp121_;
					_tmp123_ = variable_stack;
					if (_tmp123_ != NULL) {
						ValaList* _tmp124_;
						gint _tmp125_;
						gint _tmp126_;
						_tmp124_ = variable_stack;
						_tmp125_ = vala_collection_get_size ((ValaCollection*) _tmp124_);
						_tmp126_ = _tmp125_;
						_tmp122_ = _tmp126_ > 0;
					} else {
						_tmp122_ = FALSE;
					}
					if (_tmp122_) {
						ValaPhiFunction* _tmp127_;
						ValaList* _tmp128_;
						ValaList* _tmp129_;
						ValaList* _tmp130_;
						ValaList* _tmp131_;
						gint _tmp132_;
						gint _tmp133_;
						gpointer _tmp134_;
						ValaVariable* _tmp135_;
						_tmp127_ = phi;
						_tmp128_ = vala_phi_function_get_operands (_tmp127_);
						_tmp129_ = _tmp128_;
						_tmp130_ = variable_stack;
						_tmp131_ = variable_stack;
						_tmp132_ = vala_collection_get_size ((ValaCollection*) _tmp131_);
						_tmp133_ = _tmp132_;
						_tmp134_ = vala_list_get (_tmp130_, _tmp133_ - 1);
						_tmp135_ = (ValaVariable*) _tmp134_;
						vala_list_set (_tmp129_, j, _tmp135_);
						_vala_code_node_unref0 (_tmp135_);
					}
					_vala_iterable_unref0 (variable_stack);
					_vala_phi_function_unref0 (phi);
				}
				_vala_iterator_unref0 (_phi_it);
			}
		}
		_vala_iterable_unref0 (_succ_list);
	}
	{
		ValaList* _child_list = NULL;
		ValaList* _tmp136_;
		ValaList* _tmp137_;
		gint _child_size = 0;
		ValaList* _tmp138_;
		gint _tmp139_;
		gint _tmp140_;
		gint _child_index = 0;
		_tmp136_ = vala_basic_block_get_children (block);
		_tmp137_ = _vala_iterable_ref0 (_tmp136_);
		_child_list = _tmp137_;
		_tmp138_ = _child_list;
		_tmp139_ = vala_collection_get_size ((ValaCollection*) _tmp138_);
		_tmp140_ = _tmp139_;
		_child_size = _tmp140_;
		_child_index = -1;
		while (TRUE) {
			gint _tmp141_;
			gint _tmp142_;
			ValaBasicBlock* child = NULL;
			ValaList* _tmp143_;
			gpointer _tmp144_;
			ValaBasicBlock* _tmp145_;
			_child_index = _child_index + 1;
			_tmp141_ = _child_index;
			_tmp142_ = _child_size;
			if (!(_tmp141_ < _tmp142_)) {
				break;
			}
			_tmp143_ = _child_list;
			_tmp144_ = vala_list_get (_tmp143_, _child_index);
			child = (ValaBasicBlock*) _tmp144_;
			_tmp145_ = child;
			vala_flow_analyzer_check_block_variables (self, _tmp145_);
		}
		_vala_iterable_unref0 (_child_list);
	}
	{
		ValaIterator* _phi_it = NULL;
		ValaSet* _tmp146_;
		ValaIterator* _tmp147_;
		_tmp146_ = vala_basic_block_get_phi_functions (block);
		_tmp147_ = vala_iterable_iterator ((ValaIterable*) _tmp146_);
		_phi_it = _tmp147_;
		while (TRUE) {
			ValaIterator* _tmp148_;
			ValaPhiFunction* phi = NULL;
			ValaIterator* _tmp149_;
			gpointer _tmp150_;
			ValaList* variable_stack = NULL;
			ValaMap* _tmp151_;
			ValaPhiFunction* _tmp152_;
			ValaVariable* _tmp153_;
			ValaVariable* _tmp154_;
			gpointer _tmp155_;
			ValaList* _tmp156_;
			ValaList* _tmp157_;
			gint _tmp158_;
			gint _tmp159_;
			gpointer _tmp160_;
			ValaVariable* _tmp161_;
			_tmp148_ = _phi_it;
			if (!vala_iterator_next (_tmp148_)) {
				break;
			}
			_tmp149_ = _phi_it;
			_tmp150_ = vala_iterator_get (_tmp149_);
			phi = (ValaPhiFunction*) _tmp150_;
			_tmp151_ = self->priv->var_map;
			_tmp152_ = phi;
			_tmp153_ = vala_phi_function_get_original_variable (_tmp152_);
			_tmp154_ = _tmp153_;
			_tmp155_ = vala_map_get (_tmp151_, (ValaSymbol*) _tmp154_);
			variable_stack = (ValaList*) _tmp155_;
			_tmp156_ = variable_stack;
			_tmp157_ = variable_stack;
			_tmp158_ = vala_collection_get_size ((ValaCollection*) _tmp157_);
			_tmp159_ = _tmp158_;
			_tmp160_ = vala_list_remove_at (_tmp156_, _tmp159_ - 1);
			_tmp161_ = (ValaVariable*) _tmp160_;
			_vala_code_node_unref0 (_tmp161_);
			_vala_iterable_unref0 (variable_stack);
			_vala_phi_function_unref0 (phi);
		}
		_vala_iterator_unref0 (_phi_it);
	}
	{
		ValaList* _node_list = NULL;
		ValaList* _tmp162_;
		ValaList* _tmp163_;
		gint _node_size = 0;
		ValaList* _tmp164_;
		gint _tmp165_;
		gint _tmp166_;
		gint _node_index = 0;
		_tmp162_ = vala_basic_block_get_nodes (block);
		_tmp163_ = _vala_iterable_ref0 (_tmp162_);
		_node_list = _tmp163_;
		_tmp164_ = _node_list;
		_tmp165_ = vala_collection_get_size ((ValaCollection*) _tmp164_);
		_tmp166_ = _tmp165_;
		_node_size = _tmp166_;
		_node_index = -1;
		while (TRUE) {
			gint _tmp167_;
			gint _tmp168_;
			ValaCodeNode* node = NULL;
			ValaList* _tmp169_;
			gpointer _tmp170_;
			ValaArrayList* defined_variables = NULL;
			GEqualFunc _tmp171_;
			ValaArrayList* _tmp172_;
			ValaCodeNode* _tmp173_;
			ValaArrayList* _tmp174_;
			_node_index = _node_index + 1;
			_tmp167_ = _node_index;
			_tmp168_ = _node_size;
			if (!(_tmp167_ < _tmp168_)) {
				break;
			}
			_tmp169_ = _node_list;
			_tmp170_ = vala_list_get (_tmp169_, _node_index);
			node = (ValaCodeNode*) _tmp170_;
			_tmp171_ = g_direct_equal;
			_tmp172_ = vala_array_list_new (VALA_TYPE_VARIABLE, (GBoxedCopyFunc) vala_code_node_ref, (GDestroyNotify) vala_code_node_unref, _tmp171_);
			defined_variables = _tmp172_;
			_tmp173_ = node;
			_tmp174_ = defined_variables;
			vala_code_node_get_defined_variables (_tmp173_, (ValaCollection*) _tmp174_);
			{
				ValaArrayList* _variable_list = NULL;
				ValaArrayList* _tmp175_;
				ValaArrayList* _tmp176_;
				gint _variable_size = 0;
				ValaArrayList* _tmp177_;
				gint _tmp178_;
				gint _tmp179_;
				gint _variable_index = 0;
				_tmp175_ = defined_variables;
				_tmp176_ = _vala_iterable_ref0 (_tmp175_);
				_variable_list = _tmp176_;
				_tmp177_ = _variable_list;
				_tmp178_ = vala_collection_get_size ((ValaCollection*) _tmp177_);
				_tmp179_ = _tmp178_;
				_variable_size = _tmp179_;
				_variable_index = -1;
				while (TRUE) {
					gint _tmp180_;
					gint _tmp181_;
					ValaVariable* variable = NULL;
					ValaArrayList* _tmp182_;
					gpointer _tmp183_;
					ValaList* variable_stack = NULL;
					ValaMap* _tmp184_;
					ValaVariable* _tmp185_;
					gpointer _tmp186_;
					ValaList* _tmp187_;
					ValaList* _tmp188_;
					gint _tmp189_;
					gint _tmp190_;
					gpointer _tmp191_;
					ValaVariable* _tmp192_;
					_variable_index = _variable_index + 1;
					_tmp180_ = _variable_index;
					_tmp181_ = _variable_size;
					if (!(_tmp180_ < _tmp181_)) {
						break;
					}
					_tmp182_ = _variable_list;
					_tmp183_ = vala_list_get ((ValaList*) _tmp182_, _variable_index);
					variable = (ValaVariable*) _tmp183_;
					_tmp184_ = self->priv->var_map;
					_tmp185_ = variable;
					_tmp186_ = vala_map_get (_tmp184_, (ValaSymbol*) _tmp185_);
					variable_stack = (ValaList*) _tmp186_;
					_tmp187_ = variable_stack;
					_tmp188_ = variable_stack;
					_tmp189_ = vala_collection_get_size ((ValaCollection*) _tmp188_);
					_tmp190_ = _tmp189_;
					_tmp191_ = vala_list_remove_at (_tmp187_, _tmp190_ - 1);
					_tmp192_ = (ValaVariable*) _tmp191_;
					_vala_code_node_unref0 (_tmp192_);
					_vala_iterable_unref0 (variable_stack);
					_vala_code_node_unref0 (variable);
				}
				_vala_iterable_unref0 (_variable_list);
			}
			_vala_iterable_unref0 (defined_variables);
			_vala_code_node_unref0 (node);
		}
		_vala_iterable_unref0 (_node_list);
	}
}

static ValaVariable*
vala_flow_analyzer_process_assignment (ValaFlowAnalyzer* self,
                                       ValaMap* var_map,
                                       ValaVariable* var_symbol)
{
	ValaList* variable_stack = NULL;
	gpointer _tmp0_;
	ValaList* _tmp1_;
	ValaVariable* versioned_var = NULL;
	ValaList* _tmp23_;
	ValaVariable* _tmp24_;
	ValaVariable* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (var_map != NULL, NULL);
	g_return_val_if_fail (var_symbol != NULL, NULL);
	_tmp0_ = vala_map_get (var_map, (ValaSymbol*) var_symbol);
	variable_stack = (ValaList*) _tmp0_;
	_tmp1_ = variable_stack;
	if (_tmp1_ == NULL) {
		GEqualFunc _tmp2_;
		ValaArrayList* _tmp3_;
		ValaList* _tmp4_;
		_tmp2_ = g_direct_equal;
		_tmp3_ = vala_array_list_new (VALA_TYPE_VARIABLE, (GBoxedCopyFunc) vala_code_node_ref, (GDestroyNotify) vala_code_node_unref, _tmp2_);
		_vala_iterable_unref0 (variable_stack);
		variable_stack = (ValaList*) _tmp3_;
		_tmp4_ = variable_stack;
		vala_map_set (var_map, (ValaSymbol*) var_symbol, _tmp4_);
		vala_variable_set_single_assignment (var_symbol, TRUE);
	} else {
		vala_variable_set_single_assignment (var_symbol, FALSE);
	}
	if (VALA_IS_LOCAL_VARIABLE (var_symbol)) {
		ValaDataType* _tmp5_;
		ValaDataType* _tmp6_;
		ValaDataType* _tmp7_;
		ValaDataType* _tmp8_;
		const gchar* _tmp9_;
		const gchar* _tmp10_;
		ValaSourceReference* _tmp11_;
		ValaSourceReference* _tmp12_;
		ValaLocalVariable* _tmp13_;
		_tmp5_ = vala_variable_get_variable_type (var_symbol);
		_tmp6_ = _tmp5_;
		_tmp7_ = vala_data_type_copy (_tmp6_);
		_tmp8_ = _tmp7_;
		_tmp9_ = vala_symbol_get_name ((ValaSymbol*) var_symbol);
		_tmp10_ = _tmp9_;
		_tmp11_ = vala_code_node_get_source_reference ((ValaCodeNode*) var_symbol);
		_tmp12_ = _tmp11_;
		_tmp13_ = vala_local_variable_new (_tmp8_, _tmp10_, NULL, _tmp12_);
		_vala_code_node_unref0 (versioned_var);
		versioned_var = (ValaVariable*) _tmp13_;
		_vala_code_node_unref0 (_tmp8_);
	} else {
		const gchar* _tmp14_;
		const gchar* _tmp15_;
		ValaDataType* _tmp16_;
		ValaDataType* _tmp17_;
		ValaDataType* _tmp18_;
		ValaDataType* _tmp19_;
		ValaSourceReference* _tmp20_;
		ValaSourceReference* _tmp21_;
		ValaParameter* _tmp22_;
		_tmp14_ = vala_symbol_get_name ((ValaSymbol*) var_symbol);
		_tmp15_ = _tmp14_;
		_tmp16_ = vala_variable_get_variable_type (var_symbol);
		_tmp17_ = _tmp16_;
		_tmp18_ = vala_data_type_copy (_tmp17_);
		_tmp19_ = _tmp18_;
		_tmp20_ = vala_code_node_get_source_reference ((ValaCodeNode*) var_symbol);
		_tmp21_ = _tmp20_;
		_tmp22_ = vala_parameter_new (_tmp15_, _tmp19_, _tmp21_);
		_vala_code_node_unref0 (versioned_var);
		versioned_var = (ValaVariable*) _tmp22_;
		_vala_code_node_unref0 (_tmp19_);
	}
	_tmp23_ = variable_stack;
	_tmp24_ = versioned_var;
	vala_collection_add ((ValaCollection*) _tmp23_, _tmp24_);
	result = versioned_var;
	_vala_iterable_unref0 (variable_stack);
	return result;
}

static void
vala_flow_analyzer_real_visit_creation_method (ValaCodeVisitor* base,
                                               ValaCreationMethod* m)
{
	ValaFlowAnalyzer * self;
	self = (ValaFlowAnalyzer*) base;
	g_return_if_fail (m != NULL);
	vala_code_visitor_visit_method ((ValaCodeVisitor*) self, (ValaMethod*) m);
}

static void
vala_flow_analyzer_real_visit_property (ValaCodeVisitor* base,
                                        ValaProperty* prop)
{
	ValaFlowAnalyzer * self;
	self = (ValaFlowAnalyzer*) base;
	g_return_if_fail (prop != NULL);
	vala_code_node_accept_children ((ValaCodeNode*) prop, (ValaCodeVisitor*) self);
}

static void
vala_flow_analyzer_real_visit_property_accessor (ValaCodeVisitor* base,
                                                 ValaPropertyAccessor* acc)
{
	ValaFlowAnalyzer * self;
	self = (ValaFlowAnalyzer*) base;
	g_return_if_fail (acc != NULL);
	vala_flow_analyzer_visit_subroutine (self, (ValaSubroutine*) acc);
}

static void
vala_flow_analyzer_real_visit_block (ValaCodeVisitor* base,
                                     ValaBlock* b)
{
	ValaFlowAnalyzer * self;
	self = (ValaFlowAnalyzer*) base;
	g_return_if_fail (b != NULL);
	vala_code_node_accept_children ((ValaCodeNode*) b, (ValaCodeVisitor*) self);
}

static void
vala_flow_analyzer_real_visit_declaration_statement (ValaCodeVisitor* base,
                                                     ValaDeclarationStatement* stmt)
{
	ValaFlowAnalyzer * self;
	ValaSymbol* _tmp2_;
	ValaSymbol* _tmp3_;
	gboolean _tmp4_;
	gboolean _tmp5_;
	ValaBasicBlock* _tmp16_;
	ValaLocalVariable* local = NULL;
	ValaSymbol* _tmp17_;
	ValaSymbol* _tmp18_;
	gboolean _tmp19_ = FALSE;
	ValaLocalVariable* _tmp20_;
	self = (ValaFlowAnalyzer*) base;
	g_return_if_fail (stmt != NULL);
	vala_code_node_accept_children ((ValaCodeNode*) stmt, (ValaCodeVisitor*) self);
	if (vala_flow_analyzer_unreachable (self, (ValaCodeNode*) stmt)) {
		ValaSymbol* _tmp0_;
		ValaSymbol* _tmp1_;
		_tmp0_ = vala_declaration_statement_get_declaration (stmt);
		_tmp1_ = _tmp0_;
		vala_code_node_set_unreachable ((ValaCodeNode*) _tmp1_, TRUE);
		return;
	}
	_tmp2_ = vala_declaration_statement_get_declaration (stmt);
	_tmp3_ = _tmp2_;
	_tmp4_ = vala_symbol_get_used (_tmp3_);
	_tmp5_ = _tmp4_;
	if (!_tmp5_) {
		ValaSymbol* _tmp6_;
		ValaSymbol* _tmp7_;
		ValaSourceReference* _tmp8_;
		ValaSourceReference* _tmp9_;
		ValaSymbol* _tmp10_;
		ValaSymbol* _tmp11_;
		const gchar* _tmp12_;
		const gchar* _tmp13_;
		gchar* _tmp14_;
		gchar* _tmp15_;
		_tmp6_ = vala_declaration_statement_get_declaration (stmt);
		_tmp7_ = _tmp6_;
		_tmp8_ = vala_code_node_get_source_reference ((ValaCodeNode*) _tmp7_);
		_tmp9_ = _tmp8_;
		_tmp10_ = vala_declaration_statement_get_declaration (stmt);
		_tmp11_ = _tmp10_;
		_tmp12_ = vala_symbol_get_name (_tmp11_);
		_tmp13_ = _tmp12_;
		_tmp14_ = g_strdup_printf ("local variable `%s' declared but never used", _tmp13_);
		_tmp15_ = _tmp14_;
		vala_report_warning (_tmp9_, _tmp15_);
		_g_free0 (_tmp15_);
	}
	_tmp16_ = self->priv->current_block;
	vala_basic_block_add_node (_tmp16_, (ValaCodeNode*) stmt);
	_tmp17_ = vala_declaration_statement_get_declaration (stmt);
	_tmp18_ = _tmp17_;
	local = VALA_IS_LOCAL_VARIABLE (_tmp18_) ? ((ValaLocalVariable*) _tmp18_) : NULL;
	_tmp20_ = local;
	if (_tmp20_ != NULL) {
		ValaLocalVariable* _tmp21_;
		ValaExpression* _tmp22_;
		ValaExpression* _tmp23_;
		_tmp21_ = local;
		_tmp22_ = vala_variable_get_initializer ((ValaVariable*) _tmp21_);
		_tmp23_ = _tmp22_;
		_tmp19_ = _tmp23_ != NULL;
	} else {
		_tmp19_ = FALSE;
	}
	if (_tmp19_) {
		ValaLocalVariable* _tmp24_;
		ValaExpression* _tmp25_;
		ValaExpression* _tmp26_;
		_tmp24_ = local;
		_tmp25_ = vala_variable_get_initializer ((ValaVariable*) _tmp24_);
		_tmp26_ = _tmp25_;
		vala_flow_analyzer_handle_errors (self, (ValaCodeNode*) _tmp26_, FALSE);
	}
}

static void
vala_flow_analyzer_real_visit_local_variable (ValaCodeVisitor* base,
                                              ValaLocalVariable* local)
{
	ValaFlowAnalyzer * self;
	ValaExpression* _tmp0_;
	ValaExpression* _tmp1_;
	self = (ValaFlowAnalyzer*) base;
	g_return_if_fail (local != NULL);
	_tmp0_ = vala_variable_get_initializer ((ValaVariable*) local);
	_tmp1_ = _tmp0_;
	if (_tmp1_ != NULL) {
		ValaExpression* _tmp2_;
		ValaExpression* _tmp3_;
		_tmp2_ = vala_variable_get_initializer ((ValaVariable*) local);
		_tmp3_ = _tmp2_;
		vala_code_node_accept ((ValaCodeNode*) _tmp3_, (ValaCodeVisitor*) self);
	}
}

static void
vala_flow_analyzer_real_visit_expression_statement (ValaCodeVisitor* base,
                                                    ValaExpressionStatement* stmt)
{
	ValaFlowAnalyzer * self;
	ValaBasicBlock* _tmp0_;
	ValaExpression* _tmp1_;
	ValaExpression* _tmp2_;
	self = (ValaFlowAnalyzer*) base;
	g_return_if_fail (stmt != NULL);
	vala_code_node_accept_children ((ValaCodeNode*) stmt, (ValaCodeVisitor*) self);
	if (vala_flow_analyzer_unreachable (self, (ValaCodeNode*) stmt)) {
		return;
	}
	_tmp0_ = self->priv->current_block;
	vala_basic_block_add_node (_tmp0_, (ValaCodeNode*) stmt);
	vala_flow_analyzer_handle_errors (self, (ValaCodeNode*) stmt, FALSE);
	_tmp1_ = vala_expression_statement_get_expression (stmt);
	_tmp2_ = _tmp1_;
	if (VALA_IS_METHOD_CALL (_tmp2_)) {
		ValaMethodCall* expr = NULL;
		ValaExpression* _tmp3_;
		ValaExpression* _tmp4_;
		ValaMemberAccess* ma = NULL;
		ValaMethodCall* _tmp5_;
		ValaExpression* _tmp6_;
		ValaExpression* _tmp7_;
		gboolean _tmp8_ = FALSE;
		gboolean _tmp9_ = FALSE;
		ValaMemberAccess* _tmp10_;
		_tmp3_ = vala_expression_statement_get_expression (stmt);
		_tmp4_ = _tmp3_;
		expr = G_TYPE_CHECK_INSTANCE_CAST (_tmp4_, VALA_TYPE_METHOD_CALL, ValaMethodCall);
		_tmp5_ = expr;
		_tmp6_ = vala_method_call_get_call (_tmp5_);
		_tmp7_ = _tmp6_;
		ma = VALA_IS_MEMBER_ACCESS (_tmp7_) ? ((ValaMemberAccess*) _tmp7_) : NULL;
		_tmp10_ = ma;
		if (_tmp10_ != NULL) {
			ValaMemberAccess* _tmp11_;
			ValaSymbol* _tmp12_;
			ValaSymbol* _tmp13_;
			_tmp11_ = ma;
			_tmp12_ = vala_expression_get_symbol_reference ((ValaExpression*) _tmp11_);
			_tmp13_ = _tmp12_;
			_tmp9_ = _tmp13_ != NULL;
		} else {
			_tmp9_ = FALSE;
		}
		if (_tmp9_) {
			ValaMemberAccess* _tmp14_;
			ValaSymbol* _tmp15_;
			ValaSymbol* _tmp16_;
			ValaAttribute* _tmp17_;
			_tmp14_ = ma;
			_tmp15_ = vala_expression_get_symbol_reference ((ValaExpression*) _tmp14_);
			_tmp16_ = _tmp15_;
			_tmp17_ = vala_code_node_get_attribute ((ValaCodeNode*) _tmp16_, "NoReturn");
			_tmp8_ = _tmp17_ != NULL;
		} else {
			_tmp8_ = FALSE;
		}
		if (_tmp8_) {
			vala_flow_analyzer_mark_unreachable (self);
			return;
		}
	}
}

static gboolean
vala_flow_analyzer_always_true (ValaFlowAnalyzer* self,
                                ValaExpression* condition)
{
	ValaBooleanLiteral* literal = NULL;
	gboolean _tmp0_ = FALSE;
	ValaBooleanLiteral* _tmp1_;
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (condition != NULL, FALSE);
	literal = VALA_IS_BOOLEAN_LITERAL (condition) ? ((ValaBooleanLiteral*) condition) : NULL;
	_tmp1_ = literal;
	if (_tmp1_ != NULL) {
		ValaBooleanLiteral* _tmp2_;
		gboolean _tmp3_;
		gboolean _tmp4_;
		_tmp2_ = literal;
		_tmp3_ = vala_boolean_literal_get_value (_tmp2_);
		_tmp4_ = _tmp3_;
		_tmp0_ = _tmp4_;
	} else {
		_tmp0_ = FALSE;
	}
	result = _tmp0_;
	return result;
}

static gboolean
vala_flow_analyzer_always_false (ValaFlowAnalyzer* self,
                                 ValaExpression* condition)
{
	ValaBooleanLiteral* literal = NULL;
	gboolean _tmp0_ = FALSE;
	ValaBooleanLiteral* _tmp1_;
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (condition != NULL, FALSE);
	literal = VALA_IS_BOOLEAN_LITERAL (condition) ? ((ValaBooleanLiteral*) condition) : NULL;
	_tmp1_ = literal;
	if (_tmp1_ != NULL) {
		ValaBooleanLiteral* _tmp2_;
		gboolean _tmp3_;
		gboolean _tmp4_;
		_tmp2_ = literal;
		_tmp3_ = vala_boolean_literal_get_value (_tmp2_);
		_tmp4_ = _tmp3_;
		_tmp0_ = !_tmp4_;
	} else {
		_tmp0_ = FALSE;
	}
	result = _tmp0_;
	return result;
}

static void
vala_flow_analyzer_real_visit_if_statement (ValaCodeVisitor* base,
                                            ValaIfStatement* stmt)
{
	ValaFlowAnalyzer * self;
	ValaBasicBlock* _tmp0_;
	ValaExpression* _tmp1_;
	ValaExpression* _tmp2_;
	ValaExpression* _tmp3_;
	ValaExpression* _tmp4_;
	ValaBasicBlock* last_block = NULL;
	ValaBasicBlock* _tmp5_;
	ValaBasicBlock* _tmp6_;
	ValaExpression* _tmp7_;
	ValaExpression* _tmp8_;
	ValaBlock* _tmp14_;
	ValaBlock* _tmp15_;
	ValaBasicBlock* last_true_block = NULL;
	ValaBasicBlock* _tmp16_;
	ValaBasicBlock* _tmp17_;
	ValaExpression* _tmp18_;
	ValaExpression* _tmp19_;
	ValaBlock* _tmp25_;
	ValaBlock* _tmp26_;
	ValaBasicBlock* last_false_block = NULL;
	ValaBasicBlock* _tmp29_;
	ValaBasicBlock* _tmp30_;
	gboolean _tmp31_ = FALSE;
	ValaBasicBlock* _tmp32_;
	self = (ValaFlowAnalyzer*) base;
	g_return_if_fail (stmt != NULL);
	if (vala_flow_analyzer_unreachable (self, (ValaCodeNode*) stmt)) {
		return;
	}
	_tmp0_ = self->priv->current_block;
	_tmp1_ = vala_if_statement_get_condition (stmt);
	_tmp2_ = _tmp1_;
	vala_basic_block_add_node (_tmp0_, (ValaCodeNode*) _tmp2_);
	_tmp3_ = vala_if_statement_get_condition (stmt);
	_tmp4_ = _tmp3_;
	vala_flow_analyzer_handle_errors (self, (ValaCodeNode*) _tmp4_, FALSE);
	_tmp5_ = self->priv->current_block;
	_tmp6_ = _vala_basic_block_ref0 (_tmp5_);
	last_block = _tmp6_;
	_tmp7_ = vala_if_statement_get_condition (stmt);
	_tmp8_ = _tmp7_;
	if (vala_flow_analyzer_always_false (self, _tmp8_)) {
		vala_flow_analyzer_mark_unreachable (self);
	} else {
		ValaBasicBlock* _tmp9_;
		ValaSet* _tmp10_;
		ValaBasicBlock* _tmp11_;
		ValaBasicBlock* _tmp12_;
		ValaBasicBlock* _tmp13_;
		_tmp9_ = vala_basic_block_new ();
		_vala_basic_block_unref0 (self->priv->current_block);
		self->priv->current_block = _tmp9_;
		_tmp10_ = self->priv->all_basic_blocks;
		_tmp11_ = self->priv->current_block;
		vala_collection_add ((ValaCollection*) _tmp10_, _tmp11_);
		_tmp12_ = last_block;
		_tmp13_ = self->priv->current_block;
		vala_basic_block_connect (_tmp12_, _tmp13_);
	}
	_tmp14_ = vala_if_statement_get_true_statement (stmt);
	_tmp15_ = _tmp14_;
	vala_code_node_accept ((ValaCodeNode*) _tmp15_, (ValaCodeVisitor*) self);
	_tmp16_ = self->priv->current_block;
	_tmp17_ = _vala_basic_block_ref0 (_tmp16_);
	last_true_block = _tmp17_;
	_tmp18_ = vala_if_statement_get_condition (stmt);
	_tmp19_ = _tmp18_;
	if (vala_flow_analyzer_always_true (self, _tmp19_)) {
		vala_flow_analyzer_mark_unreachable (self);
	} else {
		ValaBasicBlock* _tmp20_;
		ValaSet* _tmp21_;
		ValaBasicBlock* _tmp22_;
		ValaBasicBlock* _tmp23_;
		ValaBasicBlock* _tmp24_;
		_tmp20_ = vala_basic_block_new ();
		_vala_basic_block_unref0 (self->priv->current_block);
		self->priv->current_block = _tmp20_;
		_tmp21_ = self->priv->all_basic_blocks;
		_tmp22_ = self->priv->current_block;
		vala_collection_add ((ValaCollection*) _tmp21_, _tmp22_);
		_tmp23_ = last_block;
		_tmp24_ = self->priv->current_block;
		vala_basic_block_connect (_tmp23_, _tmp24_);
	}
	_tmp25_ = vala_if_statement_get_false_statement (stmt);
	_tmp26_ = _tmp25_;
	if (_tmp26_ != NULL) {
		ValaBlock* _tmp27_;
		ValaBlock* _tmp28_;
		_tmp27_ = vala_if_statement_get_false_statement (stmt);
		_tmp28_ = _tmp27_;
		vala_code_node_accept ((ValaCodeNode*) _tmp28_, (ValaCodeVisitor*) self);
	}
	_tmp29_ = self->priv->current_block;
	_tmp30_ = _vala_basic_block_ref0 (_tmp29_);
	last_false_block = _tmp30_;
	_tmp32_ = last_true_block;
	if (_tmp32_ != NULL) {
		_tmp31_ = TRUE;
	} else {
		ValaBasicBlock* _tmp33_;
		_tmp33_ = last_false_block;
		_tmp31_ = _tmp33_ != NULL;
	}
	if (_tmp31_) {
		ValaBasicBlock* _tmp34_;
		ValaSet* _tmp35_;
		ValaBasicBlock* _tmp36_;
		ValaBasicBlock* _tmp37_;
		ValaBasicBlock* _tmp40_;
		_tmp34_ = vala_basic_block_new ();
		_vala_basic_block_unref0 (self->priv->current_block);
		self->priv->current_block = _tmp34_;
		_tmp35_ = self->priv->all_basic_blocks;
		_tmp36_ = self->priv->current_block;
		vala_collection_add ((ValaCollection*) _tmp35_, _tmp36_);
		_tmp37_ = last_true_block;
		if (_tmp37_ != NULL) {
			ValaBasicBlock* _tmp38_;
			ValaBasicBlock* _tmp39_;
			_tmp38_ = last_true_block;
			_tmp39_ = self->priv->current_block;
			vala_basic_block_connect (_tmp38_, _tmp39_);
		}
		_tmp40_ = last_false_block;
		if (_tmp40_ != NULL) {
			ValaBasicBlock* _tmp41_;
			ValaBasicBlock* _tmp42_;
			_tmp41_ = last_false_block;
			_tmp42_ = self->priv->current_block;
			vala_basic_block_connect (_tmp41_, _tmp42_);
		}
	}
	_vala_basic_block_unref0 (last_false_block);
	_vala_basic_block_unref0 (last_true_block);
	_vala_basic_block_unref0 (last_block);
}

static void
vala_flow_analyzer_real_visit_switch_statement (ValaCodeVisitor* base,
                                                ValaSwitchStatement* stmt)
{
	ValaFlowAnalyzer * self;
	ValaBasicBlock* after_switch_block = NULL;
	ValaBasicBlock* _tmp0_;
	ValaSet* _tmp1_;
	ValaBasicBlock* _tmp2_;
	ValaList* _tmp3_;
	ValaBasicBlock* _tmp4_;
	ValaFlowAnalyzerJumpTarget* _tmp5_;
	ValaFlowAnalyzerJumpTarget* _tmp6_;
	ValaBasicBlock* _tmp7_;
	ValaExpression* _tmp8_;
	ValaExpression* _tmp9_;
	ValaBasicBlock* condition_block = NULL;
	ValaBasicBlock* _tmp10_;
	ValaBasicBlock* _tmp11_;
	ValaExpression* _tmp12_;
	ValaExpression* _tmp13_;
	gboolean has_default_label = FALSE;
	ValaBasicBlock* _tmp48_;
	ValaList* _tmp49_;
	gint _tmp50_;
	gint _tmp51_;
	ValaList* _tmp54_;
	ValaList* _tmp55_;
	gint _tmp56_;
	gint _tmp57_;
	gpointer _tmp58_;
	ValaFlowAnalyzerJumpTarget* _tmp59_;
	self = (ValaFlowAnalyzer*) base;
	g_return_if_fail (stmt != NULL);
	if (vala_flow_analyzer_unreachable (self, (ValaCodeNode*) stmt)) {
		return;
	}
	_tmp0_ = vala_basic_block_new ();
	after_switch_block = _tmp0_;
	_tmp1_ = self->priv->all_basic_blocks;
	_tmp2_ = after_switch_block;
	vala_collection_add ((ValaCollection*) _tmp1_, _tmp2_);
	_tmp3_ = self->priv->jump_stack;
	_tmp4_ = after_switch_block;
	_tmp5_ = vala_flow_analyzer_jump_target_new_break_target (_tmp4_);
	_tmp6_ = _tmp5_;
	vala_collection_add ((ValaCollection*) _tmp3_, _tmp6_);
	_vala_flow_analyzer_jump_target_unref0 (_tmp6_);
	_tmp7_ = self->priv->current_block;
	_tmp8_ = vala_switch_statement_get_expression (stmt);
	_tmp9_ = _tmp8_;
	vala_basic_block_add_node (_tmp7_, (ValaCodeNode*) _tmp9_);
	_tmp10_ = self->priv->current_block;
	_tmp11_ = _vala_basic_block_ref0 (_tmp10_);
	condition_block = _tmp11_;
	_tmp12_ = vala_switch_statement_get_expression (stmt);
	_tmp13_ = _tmp12_;
	vala_flow_analyzer_handle_errors (self, (ValaCodeNode*) _tmp13_, FALSE);
	has_default_label = FALSE;
	{
		ValaList* _section_list = NULL;
		ValaList* _tmp14_;
		ValaList* _tmp15_;
		gint _section_size = 0;
		ValaList* _tmp16_;
		gint _tmp17_;
		gint _tmp18_;
		gint _section_index = 0;
		_tmp14_ = vala_switch_statement_get_sections (stmt);
		_tmp15_ = _vala_iterable_ref0 (_tmp14_);
		_section_list = _tmp15_;
		_tmp16_ = _section_list;
		_tmp17_ = vala_collection_get_size ((ValaCollection*) _tmp16_);
		_tmp18_ = _tmp17_;
		_section_size = _tmp18_;
		_section_index = -1;
		while (TRUE) {
			gint _tmp19_;
			gint _tmp20_;
			ValaSwitchSection* section = NULL;
			ValaList* _tmp21_;
			gpointer _tmp22_;
			ValaBasicBlock* _tmp23_;
			ValaSet* _tmp24_;
			ValaBasicBlock* _tmp25_;
			ValaBasicBlock* _tmp26_;
			ValaBasicBlock* _tmp27_;
			ValaSwitchSection* _tmp38_;
			ValaBasicBlock* _tmp39_;
			_section_index = _section_index + 1;
			_tmp19_ = _section_index;
			_tmp20_ = _section_size;
			if (!(_tmp19_ < _tmp20_)) {
				break;
			}
			_tmp21_ = _section_list;
			_tmp22_ = vala_list_get (_tmp21_, _section_index);
			section = (ValaSwitchSection*) _tmp22_;
			_tmp23_ = vala_basic_block_new ();
			_vala_basic_block_unref0 (self->priv->current_block);
			self->priv->current_block = _tmp23_;
			_tmp24_ = self->priv->all_basic_blocks;
			_tmp25_ = self->priv->current_block;
			vala_collection_add ((ValaCollection*) _tmp24_, _tmp25_);
			_tmp26_ = condition_block;
			_tmp27_ = self->priv->current_block;
			vala_basic_block_connect (_tmp26_, _tmp27_);
			{
				ValaList* _section_stmt_list = NULL;
				ValaSwitchSection* _tmp28_;
				ValaList* _tmp29_;
				gint _section_stmt_size = 0;
				ValaList* _tmp30_;
				gint _tmp31_;
				gint _tmp32_;
				gint _section_stmt_index = 0;
				_tmp28_ = section;
				_tmp29_ = vala_block_get_statements ((ValaBlock*) _tmp28_);
				_section_stmt_list = _tmp29_;
				_tmp30_ = _section_stmt_list;
				_tmp31_ = vala_collection_get_size ((ValaCollection*) _tmp30_);
				_tmp32_ = _tmp31_;
				_section_stmt_size = _tmp32_;
				_section_stmt_index = -1;
				while (TRUE) {
					gint _tmp33_;
					gint _tmp34_;
					ValaStatement* section_stmt = NULL;
					ValaList* _tmp35_;
					gpointer _tmp36_;
					ValaStatement* _tmp37_;
					_section_stmt_index = _section_stmt_index + 1;
					_tmp33_ = _section_stmt_index;
					_tmp34_ = _section_stmt_size;
					if (!(_tmp33_ < _tmp34_)) {
						break;
					}
					_tmp35_ = _section_stmt_list;
					_tmp36_ = vala_list_get (_tmp35_, _section_stmt_index);
					section_stmt = (ValaStatement*) _tmp36_;
					_tmp37_ = section_stmt;
					vala_code_node_accept ((ValaCodeNode*) _tmp37_, (ValaCodeVisitor*) self);
					_vala_code_node_unref0 (section_stmt);
				}
				_vala_iterable_unref0 (_section_stmt_list);
			}
			_tmp38_ = section;
			if (vala_switch_section_has_default_label (_tmp38_)) {
				has_default_label = TRUE;
			}
			_tmp39_ = self->priv->current_block;
			if (_tmp39_ != NULL) {
				ValaSwitchSection* _tmp40_;
				ValaSourceReference* _tmp41_;
				ValaSourceReference* _tmp42_;
				ValaSwitchSection* _tmp43_;
				ValaBasicBlock* _tmp44_;
				ValaBasicBlock* _tmp45_;
				_tmp40_ = section;
				_tmp41_ = vala_code_node_get_source_reference ((ValaCodeNode*) _tmp40_);
				_tmp42_ = _tmp41_;
				vala_report_error (_tmp42_, "missing break statement at end of switch section");
				_tmp43_ = section;
				vala_code_node_set_error ((ValaCodeNode*) _tmp43_, TRUE);
				_tmp44_ = self->priv->current_block;
				_tmp45_ = after_switch_block;
				vala_basic_block_connect (_tmp44_, _tmp45_);
			}
			_vala_code_node_unref0 (section);
		}
		_vala_iterable_unref0 (_section_list);
	}
	if (!has_default_label) {
		ValaBasicBlock* _tmp46_;
		ValaBasicBlock* _tmp47_;
		_tmp46_ = condition_block;
		_tmp47_ = after_switch_block;
		vala_basic_block_connect (_tmp46_, _tmp47_);
	}
	_tmp48_ = after_switch_block;
	_tmp49_ = vala_basic_block_get_predecessors (_tmp48_);
	_tmp50_ = vala_collection_get_size ((ValaCollection*) _tmp49_);
	_tmp51_ = _tmp50_;
	if (_tmp51_ > 0) {
		ValaBasicBlock* _tmp52_;
		ValaBasicBlock* _tmp53_;
		_tmp52_ = after_switch_block;
		_tmp53_ = _vala_basic_block_ref0 (_tmp52_);
		_vala_basic_block_unref0 (self->priv->current_block);
		self->priv->current_block = _tmp53_;
	} else {
		vala_flow_analyzer_mark_unreachable (self);
	}
	_tmp54_ = self->priv->jump_stack;
	_tmp55_ = self->priv->jump_stack;
	_tmp56_ = vala_collection_get_size ((ValaCollection*) _tmp55_);
	_tmp57_ = _tmp56_;
	_tmp58_ = vala_list_remove_at (_tmp54_, _tmp57_ - 1);
	_tmp59_ = (ValaFlowAnalyzerJumpTarget*) _tmp58_;
	_vala_flow_analyzer_jump_target_unref0 (_tmp59_);
	_vala_basic_block_unref0 (condition_block);
	_vala_basic_block_unref0 (after_switch_block);
}

static void
vala_flow_analyzer_real_visit_loop (ValaCodeVisitor* base,
                                    ValaLoop* stmt)
{
	ValaFlowAnalyzer * self;
	ValaBasicBlock* loop_block = NULL;
	ValaBasicBlock* _tmp0_;
	ValaSet* _tmp1_;
	ValaBasicBlock* _tmp2_;
	ValaList* _tmp3_;
	ValaBasicBlock* _tmp4_;
	ValaFlowAnalyzerJumpTarget* _tmp5_;
	ValaFlowAnalyzerJumpTarget* _tmp6_;
	ValaBasicBlock* after_loop_block = NULL;
	ValaBasicBlock* _tmp7_;
	ValaSet* _tmp8_;
	ValaBasicBlock* _tmp9_;
	ValaList* _tmp10_;
	ValaBasicBlock* _tmp11_;
	ValaFlowAnalyzerJumpTarget* _tmp12_;
	ValaFlowAnalyzerJumpTarget* _tmp13_;
	ValaBasicBlock* last_block = NULL;
	ValaBasicBlock* _tmp14_;
	ValaBasicBlock* _tmp15_;
	ValaBasicBlock* _tmp16_;
	ValaBasicBlock* _tmp17_;
	ValaBasicBlock* _tmp18_;
	ValaBasicBlock* _tmp19_;
	ValaBlock* _tmp20_;
	ValaBlock* _tmp21_;
	ValaBasicBlock* _tmp22_;
	ValaBasicBlock* _tmp25_;
	ValaList* _tmp26_;
	gint _tmp27_;
	gint _tmp28_;
	ValaList* _tmp31_;
	ValaList* _tmp32_;
	gint _tmp33_;
	gint _tmp34_;
	gpointer _tmp35_;
	ValaFlowAnalyzerJumpTarget* _tmp36_;
	ValaList* _tmp37_;
	ValaList* _tmp38_;
	gint _tmp39_;
	gint _tmp40_;
	gpointer _tmp41_;
	ValaFlowAnalyzerJumpTarget* _tmp42_;
	self = (ValaFlowAnalyzer*) base;
	g_return_if_fail (stmt != NULL);
	if (vala_flow_analyzer_unreachable (self, (ValaCodeNode*) stmt)) {
		return;
	}
	_tmp0_ = vala_basic_block_new ();
	loop_block = _tmp0_;
	_tmp1_ = self->priv->all_basic_blocks;
	_tmp2_ = loop_block;
	vala_collection_add ((ValaCollection*) _tmp1_, _tmp2_);
	_tmp3_ = self->priv->jump_stack;
	_tmp4_ = loop_block;
	_tmp5_ = vala_flow_analyzer_jump_target_new_continue_target (_tmp4_);
	_tmp6_ = _tmp5_;
	vala_collection_add ((ValaCollection*) _tmp3_, _tmp6_);
	_vala_flow_analyzer_jump_target_unref0 (_tmp6_);
	_tmp7_ = vala_basic_block_new ();
	after_loop_block = _tmp7_;
	_tmp8_ = self->priv->all_basic_blocks;
	_tmp9_ = after_loop_block;
	vala_collection_add ((ValaCollection*) _tmp8_, _tmp9_);
	_tmp10_ = self->priv->jump_stack;
	_tmp11_ = after_loop_block;
	_tmp12_ = vala_flow_analyzer_jump_target_new_break_target (_tmp11_);
	_tmp13_ = _tmp12_;
	vala_collection_add ((ValaCollection*) _tmp10_, _tmp13_);
	_vala_flow_analyzer_jump_target_unref0 (_tmp13_);
	_tmp14_ = self->priv->current_block;
	_tmp15_ = _vala_basic_block_ref0 (_tmp14_);
	last_block = _tmp15_;
	_tmp16_ = last_block;
	_tmp17_ = loop_block;
	vala_basic_block_connect (_tmp16_, _tmp17_);
	_tmp18_ = loop_block;
	_tmp19_ = _vala_basic_block_ref0 (_tmp18_);
	_vala_basic_block_unref0 (self->priv->current_block);
	self->priv->current_block = _tmp19_;
	_tmp20_ = vala_loop_get_body (stmt);
	_tmp21_ = _tmp20_;
	vala_code_node_accept ((ValaCodeNode*) _tmp21_, (ValaCodeVisitor*) self);
	_tmp22_ = self->priv->current_block;
	if (_tmp22_ != NULL) {
		ValaBasicBlock* _tmp23_;
		ValaBasicBlock* _tmp24_;
		_tmp23_ = self->priv->current_block;
		_tmp24_ = loop_block;
		vala_basic_block_connect (_tmp23_, _tmp24_);
	}
	_tmp25_ = after_loop_block;
	_tmp26_ = vala_basic_block_get_predecessors (_tmp25_);
	_tmp27_ = vala_collection_get_size ((ValaCollection*) _tmp26_);
	_tmp28_ = _tmp27_;
	if (_tmp28_ == 0) {
		vala_flow_analyzer_mark_unreachable (self);
	} else {
		ValaBasicBlock* _tmp29_;
		ValaBasicBlock* _tmp30_;
		_tmp29_ = after_loop_block;
		_tmp30_ = _vala_basic_block_ref0 (_tmp29_);
		_vala_basic_block_unref0 (self->priv->current_block);
		self->priv->current_block = _tmp30_;
	}
	_tmp31_ = self->priv->jump_stack;
	_tmp32_ = self->priv->jump_stack;
	_tmp33_ = vala_collection_get_size ((ValaCollection*) _tmp32_);
	_tmp34_ = _tmp33_;
	_tmp35_ = vala_list_remove_at (_tmp31_, _tmp34_ - 1);
	_tmp36_ = (ValaFlowAnalyzerJumpTarget*) _tmp35_;
	_vala_flow_analyzer_jump_target_unref0 (_tmp36_);
	_tmp37_ = self->priv->jump_stack;
	_tmp38_ = self->priv->jump_stack;
	_tmp39_ = vala_collection_get_size ((ValaCollection*) _tmp38_);
	_tmp40_ = _tmp39_;
	_tmp41_ = vala_list_remove_at (_tmp37_, _tmp40_ - 1);
	_tmp42_ = (ValaFlowAnalyzerJumpTarget*) _tmp41_;
	_vala_flow_analyzer_jump_target_unref0 (_tmp42_);
	_vala_basic_block_unref0 (last_block);
	_vala_basic_block_unref0 (after_loop_block);
	_vala_basic_block_unref0 (loop_block);
}

static void
vala_flow_analyzer_real_visit_foreach_statement (ValaCodeVisitor* base,
                                                 ValaForeachStatement* stmt)
{
	ValaFlowAnalyzer * self;
	ValaBasicBlock* _tmp0_;
	ValaExpression* _tmp1_;
	ValaExpression* _tmp2_;
	ValaExpression* _tmp3_;
	ValaExpression* _tmp4_;
	ValaBasicBlock* loop_block = NULL;
	ValaBasicBlock* _tmp5_;
	ValaSet* _tmp6_;
	ValaBasicBlock* _tmp7_;
	ValaList* _tmp8_;
	ValaBasicBlock* _tmp9_;
	ValaFlowAnalyzerJumpTarget* _tmp10_;
	ValaFlowAnalyzerJumpTarget* _tmp11_;
	ValaBasicBlock* after_loop_block = NULL;
	ValaBasicBlock* _tmp12_;
	ValaSet* _tmp13_;
	ValaBasicBlock* _tmp14_;
	ValaList* _tmp15_;
	ValaBasicBlock* _tmp16_;
	ValaFlowAnalyzerJumpTarget* _tmp17_;
	ValaFlowAnalyzerJumpTarget* _tmp18_;
	ValaBasicBlock* last_block = NULL;
	ValaBasicBlock* _tmp19_;
	ValaBasicBlock* _tmp20_;
	ValaBasicBlock* _tmp21_;
	ValaBasicBlock* _tmp22_;
	ValaBasicBlock* _tmp23_;
	ValaBasicBlock* _tmp24_;
	ValaBasicBlock* _tmp25_;
	ValaBlock* _tmp26_;
	ValaBlock* _tmp27_;
	ValaBasicBlock* _tmp28_;
	ValaBasicBlock* _tmp31_;
	ValaBasicBlock* _tmp32_;
	ValaBasicBlock* _tmp33_;
	ValaBasicBlock* _tmp36_;
	ValaBasicBlock* _tmp37_;
	ValaList* _tmp38_;
	ValaList* _tmp39_;
	gint _tmp40_;
	gint _tmp41_;
	gpointer _tmp42_;
	ValaFlowAnalyzerJumpTarget* _tmp43_;
	ValaList* _tmp44_;
	ValaList* _tmp45_;
	gint _tmp46_;
	gint _tmp47_;
	gpointer _tmp48_;
	ValaFlowAnalyzerJumpTarget* _tmp49_;
	self = (ValaFlowAnalyzer*) base;
	g_return_if_fail (stmt != NULL);
	if (vala_flow_analyzer_unreachable (self, (ValaCodeNode*) stmt)) {
		return;
	}
	_tmp0_ = self->priv->current_block;
	_tmp1_ = vala_foreach_statement_get_collection (stmt);
	_tmp2_ = _tmp1_;
	vala_basic_block_add_node (_tmp0_, (ValaCodeNode*) _tmp2_);
	_tmp3_ = vala_foreach_statement_get_collection (stmt);
	_tmp4_ = _tmp3_;
	vala_flow_analyzer_handle_errors (self, (ValaCodeNode*) _tmp4_, FALSE);
	_tmp5_ = vala_basic_block_new ();
	loop_block = _tmp5_;
	_tmp6_ = self->priv->all_basic_blocks;
	_tmp7_ = loop_block;
	vala_collection_add ((ValaCollection*) _tmp6_, _tmp7_);
	_tmp8_ = self->priv->jump_stack;
	_tmp9_ = loop_block;
	_tmp10_ = vala_flow_analyzer_jump_target_new_continue_target (_tmp9_);
	_tmp11_ = _tmp10_;
	vala_collection_add ((ValaCollection*) _tmp8_, _tmp11_);
	_vala_flow_analyzer_jump_target_unref0 (_tmp11_);
	_tmp12_ = vala_basic_block_new ();
	after_loop_block = _tmp12_;
	_tmp13_ = self->priv->all_basic_blocks;
	_tmp14_ = after_loop_block;
	vala_collection_add ((ValaCollection*) _tmp13_, _tmp14_);
	_tmp15_ = self->priv->jump_stack;
	_tmp16_ = after_loop_block;
	_tmp17_ = vala_flow_analyzer_jump_target_new_break_target (_tmp16_);
	_tmp18_ = _tmp17_;
	vala_collection_add ((ValaCollection*) _tmp15_, _tmp18_);
	_vala_flow_analyzer_jump_target_unref0 (_tmp18_);
	_tmp19_ = self->priv->current_block;
	_tmp20_ = _vala_basic_block_ref0 (_tmp19_);
	last_block = _tmp20_;
	_tmp21_ = last_block;
	_tmp22_ = loop_block;
	vala_basic_block_connect (_tmp21_, _tmp22_);
	_tmp23_ = loop_block;
	_tmp24_ = _vala_basic_block_ref0 (_tmp23_);
	_vala_basic_block_unref0 (self->priv->current_block);
	self->priv->current_block = _tmp24_;
	_tmp25_ = self->priv->current_block;
	vala_basic_block_add_node (_tmp25_, (ValaCodeNode*) stmt);
	_tmp26_ = vala_foreach_statement_get_body (stmt);
	_tmp27_ = _tmp26_;
	vala_code_node_accept ((ValaCodeNode*) _tmp27_, (ValaCodeVisitor*) self);
	_tmp28_ = self->priv->current_block;
	if (_tmp28_ != NULL) {
		ValaBasicBlock* _tmp29_;
		ValaBasicBlock* _tmp30_;
		_tmp29_ = self->priv->current_block;
		_tmp30_ = loop_block;
		vala_basic_block_connect (_tmp29_, _tmp30_);
	}
	_tmp31_ = last_block;
	_tmp32_ = after_loop_block;
	vala_basic_block_connect (_tmp31_, _tmp32_);
	_tmp33_ = self->priv->current_block;
	if (_tmp33_ != NULL) {
		ValaBasicBlock* _tmp34_;
		ValaBasicBlock* _tmp35_;
		_tmp34_ = self->priv->current_block;
		_tmp35_ = after_loop_block;
		vala_basic_block_connect (_tmp34_, _tmp35_);
	}
	_tmp36_ = after_loop_block;
	_tmp37_ = _vala_basic_block_ref0 (_tmp36_);
	_vala_basic_block_unref0 (self->priv->current_block);
	self->priv->current_block = _tmp37_;
	_tmp38_ = self->priv->jump_stack;
	_tmp39_ = self->priv->jump_stack;
	_tmp40_ = vala_collection_get_size ((ValaCollection*) _tmp39_);
	_tmp41_ = _tmp40_;
	_tmp42_ = vala_list_remove_at (_tmp38_, _tmp41_ - 1);
	_tmp43_ = (ValaFlowAnalyzerJumpTarget*) _tmp42_;
	_vala_flow_analyzer_jump_target_unref0 (_tmp43_);
	_tmp44_ = self->priv->jump_stack;
	_tmp45_ = self->priv->jump_stack;
	_tmp46_ = vala_collection_get_size ((ValaCollection*) _tmp45_);
	_tmp47_ = _tmp46_;
	_tmp48_ = vala_list_remove_at (_tmp44_, _tmp47_ - 1);
	_tmp49_ = (ValaFlowAnalyzerJumpTarget*) _tmp48_;
	_vala_flow_analyzer_jump_target_unref0 (_tmp49_);
	_vala_basic_block_unref0 (last_block);
	_vala_basic_block_unref0 (after_loop_block);
	_vala_basic_block_unref0 (loop_block);
}

static void
vala_flow_analyzer_real_visit_break_statement (ValaCodeVisitor* base,
                                               ValaBreakStatement* stmt)
{
	ValaFlowAnalyzer * self;
	ValaBasicBlock* _tmp0_;
	ValaSourceReference* _tmp26_;
	ValaSourceReference* _tmp27_;
	self = (ValaFlowAnalyzer*) base;
	g_return_if_fail (stmt != NULL);
	if (vala_flow_analyzer_unreachable (self, (ValaCodeNode*) stmt)) {
		return;
	}
	_tmp0_ = self->priv->current_block;
	vala_basic_block_add_node (_tmp0_, (ValaCodeNode*) stmt);
	{
		gint i = 0;
		ValaList* _tmp1_;
		gint _tmp2_;
		gint _tmp3_;
		_tmp1_ = self->priv->jump_stack;
		_tmp2_ = vala_collection_get_size ((ValaCollection*) _tmp1_);
		_tmp3_ = _tmp2_;
		i = _tmp3_ - 1;
		{
			gboolean _tmp4_ = FALSE;
			_tmp4_ = TRUE;
			while (TRUE) {
				ValaFlowAnalyzerJumpTarget* jump_target = NULL;
				ValaList* _tmp6_;
				gpointer _tmp7_;
				ValaFlowAnalyzerJumpTarget* _tmp8_;
				gboolean _tmp9_;
				gboolean _tmp10_;
				if (!_tmp4_) {
					gint _tmp5_;
					_tmp5_ = i;
					i = _tmp5_ - 1;
				}
				_tmp4_ = FALSE;
				if (!(i >= 0)) {
					break;
				}
				_tmp6_ = self->priv->jump_stack;
				_tmp7_ = vala_list_get (_tmp6_, i);
				jump_target = (ValaFlowAnalyzerJumpTarget*) _tmp7_;
				_tmp8_ = jump_target;
				_tmp9_ = vala_flow_analyzer_jump_target_get_is_break_target (_tmp8_);
				_tmp10_ = _tmp9_;
				if (_tmp10_) {
					ValaBasicBlock* _tmp11_;
					ValaFlowAnalyzerJumpTarget* _tmp12_;
					ValaBasicBlock* _tmp13_;
					ValaBasicBlock* _tmp14_;
					_tmp11_ = self->priv->current_block;
					_tmp12_ = jump_target;
					_tmp13_ = vala_flow_analyzer_jump_target_get_basic_block (_tmp12_);
					_tmp14_ = _tmp13_;
					vala_basic_block_connect (_tmp11_, _tmp14_);
					vala_flow_analyzer_mark_unreachable (self);
					_vala_flow_analyzer_jump_target_unref0 (jump_target);
					return;
				} else {
					ValaFlowAnalyzerJumpTarget* _tmp15_;
					gboolean _tmp16_;
					gboolean _tmp17_;
					_tmp15_ = jump_target;
					_tmp16_ = vala_flow_analyzer_jump_target_get_is_finally_clause (_tmp15_);
					_tmp17_ = _tmp16_;
					if (_tmp17_) {
						ValaBasicBlock* _tmp18_;
						ValaFlowAnalyzerJumpTarget* _tmp19_;
						ValaBasicBlock* _tmp20_;
						ValaBasicBlock* _tmp21_;
						ValaFlowAnalyzerJumpTarget* _tmp22_;
						ValaBasicBlock* _tmp23_;
						ValaBasicBlock* _tmp24_;
						ValaBasicBlock* _tmp25_;
						_tmp18_ = self->priv->current_block;
						_tmp19_ = jump_target;
						_tmp20_ = vala_flow_analyzer_jump_target_get_basic_block (_tmp19_);
						_tmp21_ = _tmp20_;
						vala_basic_block_connect (_tmp18_, _tmp21_);
						_tmp22_ = jump_target;
						_tmp23_ = vala_flow_analyzer_jump_target_get_last_block (_tmp22_);
						_tmp24_ = _tmp23_;
						_tmp25_ = _vala_basic_block_ref0 (_tmp24_);
						_vala_basic_block_unref0 (self->priv->current_block);
						self->priv->current_block = _tmp25_;
					}
				}
				_vala_flow_analyzer_jump_target_unref0 (jump_target);
			}
		}
	}
	_tmp26_ = vala_code_node_get_source_reference ((ValaCodeNode*) stmt);
	_tmp27_ = _tmp26_;
	vala_report_error (_tmp27_, "no enclosing loop or switch statement found");
	vala_code_node_set_error ((ValaCodeNode*) stmt, TRUE);
}

static void
vala_flow_analyzer_real_visit_continue_statement (ValaCodeVisitor* base,
                                                  ValaContinueStatement* stmt)
{
	ValaFlowAnalyzer * self;
	ValaBasicBlock* _tmp0_;
	ValaSourceReference* _tmp26_;
	ValaSourceReference* _tmp27_;
	self = (ValaFlowAnalyzer*) base;
	g_return_if_fail (stmt != NULL);
	if (vala_flow_analyzer_unreachable (self, (ValaCodeNode*) stmt)) {
		return;
	}
	_tmp0_ = self->priv->current_block;
	vala_basic_block_add_node (_tmp0_, (ValaCodeNode*) stmt);
	{
		gint i = 0;
		ValaList* _tmp1_;
		gint _tmp2_;
		gint _tmp3_;
		_tmp1_ = self->priv->jump_stack;
		_tmp2_ = vala_collection_get_size ((ValaCollection*) _tmp1_);
		_tmp3_ = _tmp2_;
		i = _tmp3_ - 1;
		{
			gboolean _tmp4_ = FALSE;
			_tmp4_ = TRUE;
			while (TRUE) {
				ValaFlowAnalyzerJumpTarget* jump_target = NULL;
				ValaList* _tmp6_;
				gpointer _tmp7_;
				ValaFlowAnalyzerJumpTarget* _tmp8_;
				gboolean _tmp9_;
				gboolean _tmp10_;
				if (!_tmp4_) {
					gint _tmp5_;
					_tmp5_ = i;
					i = _tmp5_ - 1;
				}
				_tmp4_ = FALSE;
				if (!(i >= 0)) {
					break;
				}
				_tmp6_ = self->priv->jump_stack;
				_tmp7_ = vala_list_get (_tmp6_, i);
				jump_target = (ValaFlowAnalyzerJumpTarget*) _tmp7_;
				_tmp8_ = jump_target;
				_tmp9_ = vala_flow_analyzer_jump_target_get_is_continue_target (_tmp8_);
				_tmp10_ = _tmp9_;
				if (_tmp10_) {
					ValaBasicBlock* _tmp11_;
					ValaFlowAnalyzerJumpTarget* _tmp12_;
					ValaBasicBlock* _tmp13_;
					ValaBasicBlock* _tmp14_;
					_tmp11_ = self->priv->current_block;
					_tmp12_ = jump_target;
					_tmp13_ = vala_flow_analyzer_jump_target_get_basic_block (_tmp12_);
					_tmp14_ = _tmp13_;
					vala_basic_block_connect (_tmp11_, _tmp14_);
					vala_flow_analyzer_mark_unreachable (self);
					_vala_flow_analyzer_jump_target_unref0 (jump_target);
					return;
				} else {
					ValaFlowAnalyzerJumpTarget* _tmp15_;
					gboolean _tmp16_;
					gboolean _tmp17_;
					_tmp15_ = jump_target;
					_tmp16_ = vala_flow_analyzer_jump_target_get_is_finally_clause (_tmp15_);
					_tmp17_ = _tmp16_;
					if (_tmp17_) {
						ValaBasicBlock* _tmp18_;
						ValaFlowAnalyzerJumpTarget* _tmp19_;
						ValaBasicBlock* _tmp20_;
						ValaBasicBlock* _tmp21_;
						ValaFlowAnalyzerJumpTarget* _tmp22_;
						ValaBasicBlock* _tmp23_;
						ValaBasicBlock* _tmp24_;
						ValaBasicBlock* _tmp25_;
						_tmp18_ = self->priv->current_block;
						_tmp19_ = jump_target;
						_tmp20_ = vala_flow_analyzer_jump_target_get_basic_block (_tmp19_);
						_tmp21_ = _tmp20_;
						vala_basic_block_connect (_tmp18_, _tmp21_);
						_tmp22_ = jump_target;
						_tmp23_ = vala_flow_analyzer_jump_target_get_last_block (_tmp22_);
						_tmp24_ = _tmp23_;
						_tmp25_ = _vala_basic_block_ref0 (_tmp24_);
						_vala_basic_block_unref0 (self->priv->current_block);
						self->priv->current_block = _tmp25_;
					}
				}
				_vala_flow_analyzer_jump_target_unref0 (jump_target);
			}
		}
	}
	_tmp26_ = vala_code_node_get_source_reference ((ValaCodeNode*) stmt);
	_tmp27_ = _tmp26_;
	vala_report_error (_tmp27_, "no enclosing loop found");
	vala_code_node_set_error ((ValaCodeNode*) stmt, TRUE);
}

static void
vala_flow_analyzer_real_visit_return_statement (ValaCodeVisitor* base,
                                                ValaReturnStatement* stmt)
{
	ValaFlowAnalyzer * self;
	ValaBasicBlock* _tmp0_;
	ValaExpression* _tmp1_;
	ValaExpression* _tmp2_;
	ValaSourceReference* _tmp30_;
	ValaSourceReference* _tmp31_;
	self = (ValaFlowAnalyzer*) base;
	g_return_if_fail (stmt != NULL);
	vala_code_node_accept_children ((ValaCodeNode*) stmt, (ValaCodeVisitor*) self);
	if (vala_flow_analyzer_unreachable (self, (ValaCodeNode*) stmt)) {
		return;
	}
	_tmp0_ = self->priv->current_block;
	vala_basic_block_add_node (_tmp0_, (ValaCodeNode*) stmt);
	_tmp1_ = vala_return_statement_get_return_expression (stmt);
	_tmp2_ = _tmp1_;
	if (_tmp2_ != NULL) {
		ValaExpression* _tmp3_;
		ValaExpression* _tmp4_;
		_tmp3_ = vala_return_statement_get_return_expression (stmt);
		_tmp4_ = _tmp3_;
		vala_flow_analyzer_handle_errors (self, (ValaCodeNode*) _tmp4_, FALSE);
	}
	{
		gint i = 0;
		ValaList* _tmp5_;
		gint _tmp6_;
		gint _tmp7_;
		_tmp5_ = self->priv->jump_stack;
		_tmp6_ = vala_collection_get_size ((ValaCollection*) _tmp5_);
		_tmp7_ = _tmp6_;
		i = _tmp7_ - 1;
		{
			gboolean _tmp8_ = FALSE;
			_tmp8_ = TRUE;
			while (TRUE) {
				ValaFlowAnalyzerJumpTarget* jump_target = NULL;
				ValaList* _tmp10_;
				gpointer _tmp11_;
				ValaFlowAnalyzerJumpTarget* _tmp12_;
				gboolean _tmp13_;
				gboolean _tmp14_;
				if (!_tmp8_) {
					gint _tmp9_;
					_tmp9_ = i;
					i = _tmp9_ - 1;
				}
				_tmp8_ = FALSE;
				if (!(i >= 0)) {
					break;
				}
				_tmp10_ = self->priv->jump_stack;
				_tmp11_ = vala_list_get (_tmp10_, i);
				jump_target = (ValaFlowAnalyzerJumpTarget*) _tmp11_;
				_tmp12_ = jump_target;
				_tmp13_ = vala_flow_analyzer_jump_target_get_is_return_target (_tmp12_);
				_tmp14_ = _tmp13_;
				if (_tmp14_) {
					ValaBasicBlock* _tmp15_;
					ValaFlowAnalyzerJumpTarget* _tmp16_;
					ValaBasicBlock* _tmp17_;
					ValaBasicBlock* _tmp18_;
					_tmp15_ = self->priv->current_block;
					_tmp16_ = jump_target;
					_tmp17_ = vala_flow_analyzer_jump_target_get_basic_block (_tmp16_);
					_tmp18_ = _tmp17_;
					vala_basic_block_connect (_tmp15_, _tmp18_);
					vala_flow_analyzer_mark_unreachable (self);
					_vala_flow_analyzer_jump_target_unref0 (jump_target);
					return;
				} else {
					ValaFlowAnalyzerJumpTarget* _tmp19_;
					gboolean _tmp20_;
					gboolean _tmp21_;
					_tmp19_ = jump_target;
					_tmp20_ = vala_flow_analyzer_jump_target_get_is_finally_clause (_tmp19_);
					_tmp21_ = _tmp20_;
					if (_tmp21_) {
						ValaBasicBlock* _tmp22_;
						ValaFlowAnalyzerJumpTarget* _tmp23_;
						ValaBasicBlock* _tmp24_;
						ValaBasicBlock* _tmp25_;
						ValaFlowAnalyzerJumpTarget* _tmp26_;
						ValaBasicBlock* _tmp27_;
						ValaBasicBlock* _tmp28_;
						ValaBasicBlock* _tmp29_;
						_tmp22_ = self->priv->current_block;
						_tmp23_ = jump_target;
						_tmp24_ = vala_flow_analyzer_jump_target_get_basic_block (_tmp23_);
						_tmp25_ = _tmp24_;
						vala_basic_block_connect (_tmp22_, _tmp25_);
						_tmp26_ = jump_target;
						_tmp27_ = vala_flow_analyzer_jump_target_get_last_block (_tmp26_);
						_tmp28_ = _tmp27_;
						_tmp29_ = _vala_basic_block_ref0 (_tmp28_);
						_vala_basic_block_unref0 (self->priv->current_block);
						self->priv->current_block = _tmp29_;
					}
				}
				_vala_flow_analyzer_jump_target_unref0 (jump_target);
			}
		}
	}
	_tmp30_ = vala_code_node_get_source_reference ((ValaCodeNode*) stmt);
	_tmp31_ = _tmp30_;
	vala_report_error (_tmp31_, "no enclosing loop found");
	vala_code_node_set_error ((ValaCodeNode*) stmt, TRUE);
}

static void
vala_flow_analyzer_handle_errors (ValaFlowAnalyzer* self,
                                  ValaCodeNode* node,
                                  gboolean always_fail)
{
	gboolean _tmp0_;
	gboolean _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (node != NULL);
	_tmp0_ = vala_code_node_get_tree_can_fail (node);
	_tmp1_ = _tmp0_;
	if (_tmp1_) {
		ValaBasicBlock* last_block = NULL;
		ValaBasicBlock* _tmp2_;
		ValaBasicBlock* _tmp3_;
		ValaArrayList* error_types = NULL;
		GEqualFunc _tmp4_;
		ValaArrayList* _tmp5_;
		ValaArrayList* _tmp6_;
		_tmp2_ = self->priv->current_block;
		_tmp3_ = _vala_basic_block_ref0 (_tmp2_);
		last_block = _tmp3_;
		_tmp4_ = g_direct_equal;
		_tmp5_ = vala_array_list_new (VALA_TYPE_DATA_TYPE, (GBoxedCopyFunc) vala_code_node_ref, (GDestroyNotify) vala_code_node_unref, _tmp4_);
		error_types = _tmp5_;
		_tmp6_ = error_types;
		vala_code_node_get_error_types (node, (ValaCollection*) _tmp6_, NULL);
		{
			ValaArrayList* _error_data_type_list = NULL;
			ValaArrayList* _tmp7_;
			ValaArrayList* _tmp8_;
			gint _error_data_type_size = 0;
			ValaArrayList* _tmp9_;
			gint _tmp10_;
			gint _tmp11_;
			gint _error_data_type_index = 0;
			_tmp7_ = error_types;
			_tmp8_ = _vala_iterable_ref0 (_tmp7_);
			_error_data_type_list = _tmp8_;
			_tmp9_ = _error_data_type_list;
			_tmp10_ = vala_collection_get_size ((ValaCollection*) _tmp9_);
			_tmp11_ = _tmp10_;
			_error_data_type_size = _tmp11_;
			_error_data_type_index = -1;
			while (TRUE) {
				gint _tmp12_;
				gint _tmp13_;
				ValaDataType* error_data_type = NULL;
				ValaArrayList* _tmp14_;
				gpointer _tmp15_;
				ValaErrorType* error_type = NULL;
				ValaDataType* _tmp16_;
				ValaClass* error_class = NULL;
				ValaDataType* _tmp17_;
				ValaTypeSymbol* _tmp18_;
				ValaTypeSymbol* _tmp19_;
				ValaBasicBlock* _tmp20_;
				ValaBasicBlock* _tmp21_;
				_error_data_type_index = _error_data_type_index + 1;
				_tmp12_ = _error_data_type_index;
				_tmp13_ = _error_data_type_size;
				if (!(_tmp12_ < _tmp13_)) {
					break;
				}
				_tmp14_ = _error_data_type_list;
				_tmp15_ = vala_list_get ((ValaList*) _tmp14_, _error_data_type_index);
				error_data_type = (ValaDataType*) _tmp15_;
				_tmp16_ = error_data_type;
				error_type = VALA_IS_ERROR_TYPE (_tmp16_) ? ((ValaErrorType*) _tmp16_) : NULL;
				_tmp17_ = error_data_type;
				_tmp18_ = vala_data_type_get_type_symbol (_tmp17_);
				_tmp19_ = _tmp18_;
				error_class = VALA_IS_CLASS (_tmp19_) ? ((ValaClass*) _tmp19_) : NULL;
				_tmp20_ = last_block;
				_tmp21_ = _vala_basic_block_ref0 (_tmp20_);
				_vala_basic_block_unref0 (self->priv->current_block);
				self->priv->current_block = _tmp21_;
				self->priv->unreachable_reported = TRUE;
				{
					gint i = 0;
					ValaList* _tmp22_;
					gint _tmp23_;
					gint _tmp24_;
					_tmp22_ = self->priv->jump_stack;
					_tmp23_ = vala_collection_get_size ((ValaCollection*) _tmp22_);
					_tmp24_ = _tmp23_;
					i = _tmp24_ - 1;
					{
						gboolean _tmp25_ = FALSE;
						_tmp25_ = TRUE;
						while (TRUE) {
							ValaFlowAnalyzerJumpTarget* jump_target = NULL;
							ValaList* _tmp27_;
							gpointer _tmp28_;
							ValaFlowAnalyzerJumpTarget* _tmp29_;
							gboolean _tmp30_;
							gboolean _tmp31_;
							if (!_tmp25_) {
								gint _tmp26_;
								_tmp26_ = i;
								i = _tmp26_ - 1;
							}
							_tmp25_ = FALSE;
							if (!(i >= 0)) {
								break;
							}
							_tmp27_ = self->priv->jump_stack;
							_tmp28_ = vala_list_get (_tmp27_, i);
							jump_target = (ValaFlowAnalyzerJumpTarget*) _tmp28_;
							_tmp29_ = jump_target;
							_tmp30_ = vala_flow_analyzer_jump_target_get_is_exit_target (_tmp29_);
							_tmp31_ = _tmp30_;
							if (_tmp31_) {
								ValaBasicBlock* _tmp32_;
								ValaFlowAnalyzerJumpTarget* _tmp33_;
								ValaBasicBlock* _tmp34_;
								ValaBasicBlock* _tmp35_;
								_tmp32_ = self->priv->current_block;
								_tmp33_ = jump_target;
								_tmp34_ = vala_flow_analyzer_jump_target_get_basic_block (_tmp33_);
								_tmp35_ = _tmp34_;
								vala_basic_block_connect (_tmp32_, _tmp35_);
								vala_flow_analyzer_mark_unreachable (self);
								_vala_flow_analyzer_jump_target_unref0 (jump_target);
								break;
							} else {
								ValaFlowAnalyzerJumpTarget* _tmp36_;
								gboolean _tmp37_;
								gboolean _tmp38_;
								_tmp36_ = jump_target;
								_tmp37_ = vala_flow_analyzer_jump_target_get_is_error_target (_tmp36_);
								_tmp38_ = _tmp37_;
								if (_tmp38_) {
									ValaCodeContext* _tmp39_;
									ValaProfile _tmp40_;
									ValaProfile _tmp41_;
									_tmp39_ = self->priv->context;
									_tmp40_ = vala_code_context_get_profile (_tmp39_);
									_tmp41_ = _tmp40_;
									if (_tmp41_ == VALA_PROFILE_GOBJECT) {
										gboolean _tmp42_ = FALSE;
										ValaFlowAnalyzerJumpTarget* _tmp43_;
										ValaErrorDomain* _tmp44_;
										ValaErrorDomain* _tmp45_;
										_tmp43_ = jump_target;
										_tmp44_ = vala_flow_analyzer_jump_target_get_error_domain (_tmp43_);
										_tmp45_ = _tmp44_;
										if (_tmp45_ == NULL) {
											_tmp42_ = TRUE;
										} else {
											gboolean _tmp46_ = FALSE;
											ValaFlowAnalyzerJumpTarget* _tmp47_;
											ValaErrorDomain* _tmp48_;
											ValaErrorDomain* _tmp49_;
											ValaErrorType* _tmp50_;
											ValaErrorDomain* _tmp51_;
											ValaErrorDomain* _tmp52_;
											_tmp47_ = jump_target;
											_tmp48_ = vala_flow_analyzer_jump_target_get_error_domain (_tmp47_);
											_tmp49_ = _tmp48_;
											_tmp50_ = error_type;
											_tmp51_ = vala_error_type_get_error_domain (_tmp50_);
											_tmp52_ = _tmp51_;
											if (_tmp49_ == _tmp52_) {
												gboolean _tmp53_ = FALSE;
												ValaFlowAnalyzerJumpTarget* _tmp54_;
												ValaErrorCode* _tmp55_;
												ValaErrorCode* _tmp56_;
												_tmp54_ = jump_target;
												_tmp55_ = vala_flow_analyzer_jump_target_get_error_code (_tmp54_);
												_tmp56_ = _tmp55_;
												if (_tmp56_ == NULL) {
													_tmp53_ = TRUE;
												} else {
													ValaFlowAnalyzerJumpTarget* _tmp57_;
													ValaErrorCode* _tmp58_;
													ValaErrorCode* _tmp59_;
													ValaErrorType* _tmp60_;
													ValaErrorCode* _tmp61_;
													ValaErrorCode* _tmp62_;
													_tmp57_ = jump_target;
													_tmp58_ = vala_flow_analyzer_jump_target_get_error_code (_tmp57_);
													_tmp59_ = _tmp58_;
													_tmp60_ = error_type;
													_tmp61_ = vala_error_type_get_error_code (_tmp60_);
													_tmp62_ = _tmp61_;
													_tmp53_ = _tmp59_ == _tmp62_;
												}
												_tmp46_ = _tmp53_;
											} else {
												_tmp46_ = FALSE;
											}
											_tmp42_ = _tmp46_;
										}
										if (_tmp42_) {
											ValaBasicBlock* _tmp63_;
											ValaFlowAnalyzerJumpTarget* _tmp64_;
											ValaBasicBlock* _tmp65_;
											ValaBasicBlock* _tmp66_;
											_tmp63_ = self->priv->current_block;
											_tmp64_ = jump_target;
											_tmp65_ = vala_flow_analyzer_jump_target_get_basic_block (_tmp64_);
											_tmp66_ = _tmp65_;
											vala_basic_block_connect (_tmp63_, _tmp66_);
											vala_flow_analyzer_mark_unreachable (self);
											_vala_flow_analyzer_jump_target_unref0 (jump_target);
											break;
										} else {
											gboolean _tmp67_ = FALSE;
											ValaErrorType* _tmp68_;
											ValaErrorDomain* _tmp69_;
											ValaErrorDomain* _tmp70_;
											_tmp68_ = error_type;
											_tmp69_ = vala_error_type_get_error_domain (_tmp68_);
											_tmp70_ = _tmp69_;
											if (_tmp70_ == NULL) {
												_tmp67_ = TRUE;
											} else {
												gboolean _tmp71_ = FALSE;
												ValaErrorType* _tmp72_;
												ValaErrorDomain* _tmp73_;
												ValaErrorDomain* _tmp74_;
												ValaFlowAnalyzerJumpTarget* _tmp75_;
												ValaErrorDomain* _tmp76_;
												ValaErrorDomain* _tmp77_;
												_tmp72_ = error_type;
												_tmp73_ = vala_error_type_get_error_domain (_tmp72_);
												_tmp74_ = _tmp73_;
												_tmp75_ = jump_target;
												_tmp76_ = vala_flow_analyzer_jump_target_get_error_domain (_tmp75_);
												_tmp77_ = _tmp76_;
												if (_tmp74_ == _tmp77_) {
													gboolean _tmp78_ = FALSE;
													ValaErrorType* _tmp79_;
													ValaErrorCode* _tmp80_;
													ValaErrorCode* _tmp81_;
													_tmp79_ = error_type;
													_tmp80_ = vala_error_type_get_error_code (_tmp79_);
													_tmp81_ = _tmp80_;
													if (_tmp81_ == NULL) {
														_tmp78_ = TRUE;
													} else {
														ValaErrorType* _tmp82_;
														ValaErrorCode* _tmp83_;
														ValaErrorCode* _tmp84_;
														ValaFlowAnalyzerJumpTarget* _tmp85_;
														ValaErrorCode* _tmp86_;
														ValaErrorCode* _tmp87_;
														_tmp82_ = error_type;
														_tmp83_ = vala_error_type_get_error_code (_tmp82_);
														_tmp84_ = _tmp83_;
														_tmp85_ = jump_target;
														_tmp86_ = vala_flow_analyzer_jump_target_get_error_code (_tmp85_);
														_tmp87_ = _tmp86_;
														_tmp78_ = _tmp84_ == _tmp87_;
													}
													_tmp71_ = _tmp78_;
												} else {
													_tmp71_ = FALSE;
												}
												_tmp67_ = _tmp71_;
											}
											if (_tmp67_) {
												ValaBasicBlock* _tmp88_;
												ValaFlowAnalyzerJumpTarget* _tmp89_;
												ValaBasicBlock* _tmp90_;
												ValaBasicBlock* _tmp91_;
												_tmp88_ = self->priv->current_block;
												_tmp89_ = jump_target;
												_tmp90_ = vala_flow_analyzer_jump_target_get_basic_block (_tmp89_);
												_tmp91_ = _tmp90_;
												vala_basic_block_connect (_tmp88_, _tmp91_);
											}
										}
									} else {
										gboolean _tmp92_ = FALSE;
										ValaFlowAnalyzerJumpTarget* _tmp93_;
										ValaClass* _tmp94_;
										ValaClass* _tmp95_;
										_tmp93_ = jump_target;
										_tmp94_ = vala_flow_analyzer_jump_target_get_error_class (_tmp93_);
										_tmp95_ = _tmp94_;
										if (_tmp95_ == NULL) {
											_tmp92_ = TRUE;
										} else {
											ValaFlowAnalyzerJumpTarget* _tmp96_;
											ValaClass* _tmp97_;
											ValaClass* _tmp98_;
											ValaClass* _tmp99_;
											_tmp96_ = jump_target;
											_tmp97_ = vala_flow_analyzer_jump_target_get_error_class (_tmp96_);
											_tmp98_ = _tmp97_;
											_tmp99_ = error_class;
											_tmp92_ = _tmp98_ == _tmp99_;
										}
										if (_tmp92_) {
											ValaBasicBlock* _tmp100_;
											ValaFlowAnalyzerJumpTarget* _tmp101_;
											ValaBasicBlock* _tmp102_;
											ValaBasicBlock* _tmp103_;
											_tmp100_ = self->priv->current_block;
											_tmp101_ = jump_target;
											_tmp102_ = vala_flow_analyzer_jump_target_get_basic_block (_tmp101_);
											_tmp103_ = _tmp102_;
											vala_basic_block_connect (_tmp100_, _tmp103_);
											vala_flow_analyzer_mark_unreachable (self);
											_vala_flow_analyzer_jump_target_unref0 (jump_target);
											break;
										} else {
											ValaFlowAnalyzerJumpTarget* _tmp104_;
											ValaClass* _tmp105_;
											ValaClass* _tmp106_;
											ValaClass* _tmp107_;
											_tmp104_ = jump_target;
											_tmp105_ = vala_flow_analyzer_jump_target_get_error_class (_tmp104_);
											_tmp106_ = _tmp105_;
											_tmp107_ = error_class;
											if (vala_typesymbol_is_subtype_of ((ValaTypeSymbol*) _tmp106_, (ValaTypeSymbol*) _tmp107_)) {
												ValaBasicBlock* _tmp108_;
												ValaFlowAnalyzerJumpTarget* _tmp109_;
												ValaBasicBlock* _tmp110_;
												ValaBasicBlock* _tmp111_;
												_tmp108_ = self->priv->current_block;
												_tmp109_ = jump_target;
												_tmp110_ = vala_flow_analyzer_jump_target_get_basic_block (_tmp109_);
												_tmp111_ = _tmp110_;
												vala_basic_block_connect (_tmp108_, _tmp111_);
											}
										}
									}
								} else {
									ValaFlowAnalyzerJumpTarget* _tmp112_;
									gboolean _tmp113_;
									gboolean _tmp114_;
									_tmp112_ = jump_target;
									_tmp113_ = vala_flow_analyzer_jump_target_get_is_finally_clause (_tmp112_);
									_tmp114_ = _tmp113_;
									if (_tmp114_) {
										ValaBasicBlock* _tmp115_;
										ValaFlowAnalyzerJumpTarget* _tmp116_;
										ValaBasicBlock* _tmp117_;
										ValaBasicBlock* _tmp118_;
										ValaFlowAnalyzerJumpTarget* _tmp119_;
										ValaBasicBlock* _tmp120_;
										ValaBasicBlock* _tmp121_;
										ValaBasicBlock* _tmp122_;
										_tmp115_ = self->priv->current_block;
										_tmp116_ = jump_target;
										_tmp117_ = vala_flow_analyzer_jump_target_get_basic_block (_tmp116_);
										_tmp118_ = _tmp117_;
										vala_basic_block_connect (_tmp115_, _tmp118_);
										_tmp119_ = jump_target;
										_tmp120_ = vala_flow_analyzer_jump_target_get_last_block (_tmp119_);
										_tmp121_ = _tmp120_;
										_tmp122_ = _vala_basic_block_ref0 (_tmp121_);
										_vala_basic_block_unref0 (self->priv->current_block);
										self->priv->current_block = _tmp122_;
									}
								}
							}
							_vala_flow_analyzer_jump_target_unref0 (jump_target);
						}
					}
				}
				_vala_code_node_unref0 (error_data_type);
			}
			_vala_iterable_unref0 (_error_data_type_list);
		}
		if (!always_fail) {
			ValaBasicBlock* _tmp123_;
			ValaSet* _tmp124_;
			ValaBasicBlock* _tmp125_;
			ValaBasicBlock* _tmp126_;
			ValaBasicBlock* _tmp127_;
			_tmp123_ = vala_basic_block_new ();
			_vala_basic_block_unref0 (self->priv->current_block);
			self->priv->current_block = _tmp123_;
			_tmp124_ = self->priv->all_basic_blocks;
			_tmp125_ = self->priv->current_block;
			vala_collection_add ((ValaCollection*) _tmp124_, _tmp125_);
			_tmp126_ = last_block;
			_tmp127_ = self->priv->current_block;
			vala_basic_block_connect (_tmp126_, _tmp127_);
		}
		_vala_iterable_unref0 (error_types);
		_vala_basic_block_unref0 (last_block);
	}
}

static void
vala_flow_analyzer_real_visit_yield_statement (ValaCodeVisitor* base,
                                               ValaYieldStatement* stmt)
{
	ValaFlowAnalyzer * self;
	self = (ValaFlowAnalyzer*) base;
	g_return_if_fail (stmt != NULL);
	if (vala_flow_analyzer_unreachable (self, (ValaCodeNode*) stmt)) {
		return;
	}
	vala_code_node_accept_children ((ValaCodeNode*) stmt, (ValaCodeVisitor*) self);
}

static void
vala_flow_analyzer_real_visit_throw_statement (ValaCodeVisitor* base,
                                               ValaThrowStatement* stmt)
{
	ValaFlowAnalyzer * self;
	ValaBasicBlock* _tmp0_;
	self = (ValaFlowAnalyzer*) base;
	g_return_if_fail (stmt != NULL);
	if (vala_flow_analyzer_unreachable (self, (ValaCodeNode*) stmt)) {
		return;
	}
	_tmp0_ = self->priv->current_block;
	vala_basic_block_add_node (_tmp0_, (ValaCodeNode*) stmt);
	vala_flow_analyzer_handle_errors (self, (ValaCodeNode*) stmt, TRUE);
}

static void
vala_flow_analyzer_real_visit_try_statement (ValaCodeVisitor* base,
                                             ValaTryStatement* stmt)
{
	ValaFlowAnalyzer * self;
	ValaBasicBlock* before_try_block = NULL;
	ValaBasicBlock* _tmp0_;
	ValaBasicBlock* _tmp1_;
	ValaBasicBlock* after_try_block = NULL;
	ValaBasicBlock* _tmp2_;
	ValaSet* _tmp3_;
	ValaBasicBlock* _tmp4_;
	ValaBasicBlock* finally_block = NULL;
	ValaBlock* _tmp5_;
	ValaBlock* _tmp6_;
	gint finally_jump_stack_size = 0;
	ValaList* _tmp38_;
	gint _tmp39_;
	gint _tmp40_;
	ValaList* catch_clauses = NULL;
	ValaList* _tmp41_;
	ValaList* _tmp42_;
	ValaBasicBlock* _tmp95_;
	ValaBasicBlock* _tmp96_;
	ValaBlock* _tmp97_;
	ValaBlock* _tmp98_;
	ValaBasicBlock* _tmp99_;
	ValaList* catch_stack = NULL;
	GEqualFunc _tmp107_;
	ValaArrayList* _tmp108_;
	ValaBasicBlock* _tmp196_;
	ValaBasicBlock* _tmp203_;
	ValaList* _tmp204_;
	gint _tmp205_;
	gint _tmp206_;
	self = (ValaFlowAnalyzer*) base;
	g_return_if_fail (stmt != NULL);
	if (vala_flow_analyzer_unreachable (self, (ValaCodeNode*) stmt)) {
		return;
	}
	_tmp0_ = self->priv->current_block;
	_tmp1_ = _vala_basic_block_ref0 (_tmp0_);
	before_try_block = _tmp1_;
	_tmp2_ = vala_basic_block_new ();
	after_try_block = _tmp2_;
	_tmp3_ = self->priv->all_basic_blocks;
	_tmp4_ = after_try_block;
	vala_collection_add ((ValaCollection*) _tmp3_, _tmp4_);
	finally_block = NULL;
	_tmp5_ = vala_try_statement_get_finally_body (stmt);
	_tmp6_ = _tmp5_;
	if (_tmp6_ != NULL) {
		ValaBasicBlock* _tmp7_;
		ValaSet* _tmp8_;
		ValaBasicBlock* _tmp9_;
		ValaBasicBlock* _tmp10_;
		ValaBasicBlock* _tmp11_;
		ValaBasicBlock* invalid_block = NULL;
		ValaBasicBlock* _tmp12_;
		ValaSet* _tmp13_;
		ValaBasicBlock* _tmp14_;
		ValaList* _tmp15_;
		ValaBasicBlock* _tmp16_;
		ValaFlowAnalyzerJumpTarget* _tmp17_;
		ValaFlowAnalyzerJumpTarget* _tmp18_;
		ValaBlock* _tmp19_;
		ValaBlock* _tmp20_;
		ValaBasicBlock* _tmp21_;
		ValaList* _tmp22_;
		gint _tmp23_;
		gint _tmp24_;
		ValaList* _tmp27_;
		ValaList* _tmp28_;
		gint _tmp29_;
		gint _tmp30_;
		gpointer _tmp31_;
		ValaFlowAnalyzerJumpTarget* _tmp32_;
		ValaList* _tmp33_;
		ValaBasicBlock* _tmp34_;
		ValaBasicBlock* _tmp35_;
		ValaFlowAnalyzerJumpTarget* _tmp36_;
		ValaFlowAnalyzerJumpTarget* _tmp37_;
		_tmp7_ = vala_basic_block_new ();
		_vala_basic_block_unref0 (finally_block);
		finally_block = _tmp7_;
		_tmp8_ = self->priv->all_basic_blocks;
		_tmp9_ = finally_block;
		vala_collection_add ((ValaCollection*) _tmp8_, _tmp9_);
		_tmp10_ = finally_block;
		_tmp11_ = _vala_basic_block_ref0 (_tmp10_);
		_vala_basic_block_unref0 (self->priv->current_block);
		self->priv->current_block = _tmp11_;
		_tmp12_ = vala_basic_block_new ();
		invalid_block = _tmp12_;
		_tmp13_ = self->priv->all_basic_blocks;
		_tmp14_ = invalid_block;
		vala_collection_add ((ValaCollection*) _tmp13_, _tmp14_);
		_tmp15_ = self->priv->jump_stack;
		_tmp16_ = invalid_block;
		_tmp17_ = vala_flow_analyzer_jump_target_new_any_target (_tmp16_);
		_tmp18_ = _tmp17_;
		vala_collection_add ((ValaCollection*) _tmp15_, _tmp18_);
		_vala_flow_analyzer_jump_target_unref0 (_tmp18_);
		_tmp19_ = vala_try_statement_get_finally_body (stmt);
		_tmp20_ = _tmp19_;
		vala_code_node_accept ((ValaCodeNode*) _tmp20_, (ValaCodeVisitor*) self);
		_tmp21_ = invalid_block;
		_tmp22_ = vala_basic_block_get_predecessors (_tmp21_);
		_tmp23_ = vala_collection_get_size ((ValaCollection*) _tmp22_);
		_tmp24_ = _tmp23_;
		if (_tmp24_ > 0) {
			ValaSourceReference* _tmp25_;
			ValaSourceReference* _tmp26_;
			_tmp25_ = vala_code_node_get_source_reference ((ValaCodeNode*) stmt);
			_tmp26_ = _tmp25_;
			vala_report_error (_tmp26_, "jump out of finally block not permitted");
			vala_code_node_set_error ((ValaCodeNode*) stmt, TRUE);
			_vala_basic_block_unref0 (invalid_block);
			_vala_basic_block_unref0 (finally_block);
			_vala_basic_block_unref0 (after_try_block);
			_vala_basic_block_unref0 (before_try_block);
			return;
		}
		_tmp27_ = self->priv->jump_stack;
		_tmp28_ = self->priv->jump_stack;
		_tmp29_ = vala_collection_get_size ((ValaCollection*) _tmp28_);
		_tmp30_ = _tmp29_;
		_tmp31_ = vala_list_remove_at (_tmp27_, _tmp30_ - 1);
		_tmp32_ = (ValaFlowAnalyzerJumpTarget*) _tmp31_;
		_vala_flow_analyzer_jump_target_unref0 (_tmp32_);
		_tmp33_ = self->priv->jump_stack;
		_tmp34_ = finally_block;
		_tmp35_ = self->priv->current_block;
		_tmp36_ = vala_flow_analyzer_jump_target_new_finally_clause (_tmp34_, _tmp35_);
		_tmp37_ = _tmp36_;
		vala_collection_add ((ValaCollection*) _tmp33_, _tmp37_);
		_vala_flow_analyzer_jump_target_unref0 (_tmp37_);
		_vala_basic_block_unref0 (invalid_block);
	}
	_tmp38_ = self->priv->jump_stack;
	_tmp39_ = vala_collection_get_size ((ValaCollection*) _tmp38_);
	_tmp40_ = _tmp39_;
	finally_jump_stack_size = _tmp40_;
	_tmp41_ = vala_try_statement_get_catch_clauses (stmt);
	_tmp42_ = _vala_iterable_ref0 (_tmp41_);
	catch_clauses = _tmp42_;
	{
		gint i = 0;
		ValaList* _tmp43_;
		gint _tmp44_;
		gint _tmp45_;
		_tmp43_ = catch_clauses;
		_tmp44_ = vala_collection_get_size ((ValaCollection*) _tmp43_);
		_tmp45_ = _tmp44_;
		i = _tmp45_ - 1;
		{
			gboolean _tmp46_ = FALSE;
			_tmp46_ = TRUE;
			while (TRUE) {
				ValaCatchClause* catch_clause = NULL;
				ValaList* _tmp48_;
				gpointer _tmp49_;
				ValaBasicBlock* error_block = NULL;
				ValaBasicBlock* _tmp50_;
				ValaSet* _tmp51_;
				ValaBasicBlock* _tmp52_;
				gboolean _tmp53_ = FALSE;
				ValaCatchClause* _tmp54_;
				ValaDataType* _tmp55_;
				ValaDataType* _tmp56_;
				if (!_tmp46_) {
					gint _tmp47_;
					_tmp47_ = i;
					i = _tmp47_ - 1;
				}
				_tmp46_ = FALSE;
				if (!(i >= 0)) {
					break;
				}
				_tmp48_ = catch_clauses;
				_tmp49_ = vala_list_get (_tmp48_, i);
				catch_clause = (ValaCatchClause*) _tmp49_;
				_tmp50_ = vala_basic_block_new ();
				error_block = _tmp50_;
				_tmp51_ = self->priv->all_basic_blocks;
				_tmp52_ = error_block;
				vala_collection_add ((ValaCollection*) _tmp51_, _tmp52_);
				_tmp54_ = catch_clause;
				_tmp55_ = vala_catch_clause_get_error_type (_tmp54_);
				_tmp56_ = _tmp55_;
				if (_tmp56_ != NULL) {
					ValaCatchClause* _tmp57_;
					gboolean _tmp58_;
					gboolean _tmp59_;
					_tmp57_ = catch_clause;
					_tmp58_ = vala_code_node_get_error ((ValaCodeNode*) _tmp57_);
					_tmp59_ = _tmp58_;
					_tmp53_ = !_tmp59_;
				} else {
					_tmp53_ = FALSE;
				}
				if (_tmp53_) {
					ValaCodeContext* _tmp60_;
					ValaProfile _tmp61_;
					ValaProfile _tmp62_;
					_tmp60_ = self->priv->context;
					_tmp61_ = vala_code_context_get_profile (_tmp60_);
					_tmp62_ = _tmp61_;
					if (_tmp62_ == VALA_PROFILE_GOBJECT) {
						ValaErrorType* error_type = NULL;
						ValaCatchClause* _tmp63_;
						ValaDataType* _tmp64_;
						ValaDataType* _tmp65_;
						ValaList* _tmp66_;
						ValaBasicBlock* _tmp67_;
						ValaCatchClause* _tmp68_;
						ValaCatchClause* _tmp69_;
						ValaDataType* _tmp70_;
						ValaDataType* _tmp71_;
						ValaTypeSymbol* _tmp72_;
						ValaTypeSymbol* _tmp73_;
						ValaErrorType* _tmp74_;
						ValaErrorCode* _tmp75_;
						ValaErrorCode* _tmp76_;
						ValaFlowAnalyzerJumpTarget* _tmp77_;
						ValaFlowAnalyzerJumpTarget* _tmp78_;
						_tmp63_ = catch_clause;
						_tmp64_ = vala_catch_clause_get_error_type (_tmp63_);
						_tmp65_ = _tmp64_;
						error_type = G_TYPE_CHECK_INSTANCE_CAST (_tmp65_, VALA_TYPE_ERROR_TYPE, ValaErrorType);
						_tmp66_ = self->priv->jump_stack;
						_tmp67_ = error_block;
						_tmp68_ = catch_clause;
						_tmp69_ = catch_clause;
						_tmp70_ = vala_catch_clause_get_error_type (_tmp69_);
						_tmp71_ = _tmp70_;
						_tmp72_ = vala_data_type_get_type_symbol (_tmp71_);
						_tmp73_ = _tmp72_;
						_tmp74_ = error_type;
						_tmp75_ = vala_error_type_get_error_code (_tmp74_);
						_tmp76_ = _tmp75_;
						_tmp77_ = vala_flow_analyzer_jump_target_new_error_target (_tmp67_, _tmp68_, VALA_IS_ERROR_DOMAIN (_tmp73_) ? ((ValaErrorDomain*) _tmp73_) : NULL, _tmp76_, NULL);
						_tmp78_ = _tmp77_;
						vala_collection_add ((ValaCollection*) _tmp66_, _tmp78_);
						_vala_flow_analyzer_jump_target_unref0 (_tmp78_);
					} else {
						ValaClass* error_class = NULL;
						ValaCatchClause* _tmp79_;
						ValaDataType* _tmp80_;
						ValaDataType* _tmp81_;
						ValaTypeSymbol* _tmp82_;
						ValaTypeSymbol* _tmp83_;
						ValaList* _tmp84_;
						ValaBasicBlock* _tmp85_;
						ValaCatchClause* _tmp86_;
						ValaClass* _tmp87_;
						ValaFlowAnalyzerJumpTarget* _tmp88_;
						ValaFlowAnalyzerJumpTarget* _tmp89_;
						_tmp79_ = catch_clause;
						_tmp80_ = vala_catch_clause_get_error_type (_tmp79_);
						_tmp81_ = _tmp80_;
						_tmp82_ = vala_data_type_get_type_symbol (_tmp81_);
						_tmp83_ = _tmp82_;
						error_class = VALA_IS_CLASS (_tmp83_) ? ((ValaClass*) _tmp83_) : NULL;
						_tmp84_ = self->priv->jump_stack;
						_tmp85_ = error_block;
						_tmp86_ = catch_clause;
						_tmp87_ = error_class;
						_tmp88_ = vala_flow_analyzer_jump_target_new_error_target (_tmp85_, _tmp86_, NULL, NULL, _tmp87_);
						_tmp89_ = _tmp88_;
						vala_collection_add ((ValaCollection*) _tmp84_, _tmp89_);
						_vala_flow_analyzer_jump_target_unref0 (_tmp89_);
					}
				} else {
					ValaList* _tmp90_;
					ValaBasicBlock* _tmp91_;
					ValaCatchClause* _tmp92_;
					ValaFlowAnalyzerJumpTarget* _tmp93_;
					ValaFlowAnalyzerJumpTarget* _tmp94_;
					_tmp90_ = self->priv->jump_stack;
					_tmp91_ = error_block;
					_tmp92_ = catch_clause;
					_tmp93_ = vala_flow_analyzer_jump_target_new_error_target (_tmp91_, _tmp92_, NULL, NULL, NULL);
					_tmp94_ = _tmp93_;
					vala_collection_add ((ValaCollection*) _tmp90_, _tmp94_);
					_vala_flow_analyzer_jump_target_unref0 (_tmp94_);
				}
				_vala_basic_block_unref0 (error_block);
				_vala_code_node_unref0 (catch_clause);
			}
		}
	}
	_tmp95_ = before_try_block;
	_tmp96_ = _vala_basic_block_ref0 (_tmp95_);
	_vala_basic_block_unref0 (self->priv->current_block);
	self->priv->current_block = _tmp96_;
	_tmp97_ = vala_try_statement_get_body (stmt);
	_tmp98_ = _tmp97_;
	vala_code_node_accept ((ValaCodeNode*) _tmp98_, (ValaCodeVisitor*) self);
	_tmp99_ = self->priv->current_block;
	if (_tmp99_ != NULL) {
		ValaBasicBlock* _tmp100_;
		ValaBasicBlock* _tmp105_;
		ValaBasicBlock* _tmp106_;
		_tmp100_ = finally_block;
		if (_tmp100_ != NULL) {
			ValaBasicBlock* _tmp101_;
			ValaBasicBlock* _tmp102_;
			ValaBasicBlock* _tmp103_;
			ValaBasicBlock* _tmp104_;
			_tmp101_ = self->priv->current_block;
			_tmp102_ = finally_block;
			vala_basic_block_connect (_tmp101_, _tmp102_);
			_tmp103_ = finally_block;
			_tmp104_ = _vala_basic_block_ref0 (_tmp103_);
			_vala_basic_block_unref0 (self->priv->current_block);
			self->priv->current_block = _tmp104_;
		}
		_tmp105_ = self->priv->current_block;
		_tmp106_ = after_try_block;
		vala_basic_block_connect (_tmp105_, _tmp106_);
	}
	_tmp107_ = g_direct_equal;
	_tmp108_ = vala_array_list_new (VALA_FLOW_ANALYZER_TYPE_JUMP_TARGET, (GBoxedCopyFunc) vala_flow_analyzer_jump_target_ref, (GDestroyNotify) vala_flow_analyzer_jump_target_unref, _tmp107_);
	catch_stack = (ValaList*) _tmp108_;
	{
		gint i = 0;
		ValaList* _tmp109_;
		gint _tmp110_;
		gint _tmp111_;
		_tmp109_ = self->priv->jump_stack;
		_tmp110_ = vala_collection_get_size ((ValaCollection*) _tmp109_);
		_tmp111_ = _tmp110_;
		i = _tmp111_ - 1;
		{
			gboolean _tmp112_ = FALSE;
			_tmp112_ = TRUE;
			while (TRUE) {
				ValaFlowAnalyzerJumpTarget* jump_target = NULL;
				ValaList* _tmp114_;
				gpointer _tmp115_;
				ValaList* _tmp116_;
				ValaFlowAnalyzerJumpTarget* _tmp117_;
				if (!_tmp112_) {
					gint _tmp113_;
					_tmp113_ = i;
					i = _tmp113_ - 1;
				}
				_tmp112_ = FALSE;
				if (!(i >= finally_jump_stack_size)) {
					break;
				}
				_tmp114_ = self->priv->jump_stack;
				_tmp115_ = vala_list_remove_at (_tmp114_, i);
				jump_target = (ValaFlowAnalyzerJumpTarget*) _tmp115_;
				_tmp116_ = catch_stack;
				_tmp117_ = jump_target;
				vala_collection_add ((ValaCollection*) _tmp116_, _tmp117_);
				_vala_flow_analyzer_jump_target_unref0 (jump_target);
			}
		}
	}
	{
		ValaList* _jump_target_list = NULL;
		ValaList* _tmp118_;
		ValaList* _tmp119_;
		gint _jump_target_size = 0;
		ValaList* _tmp120_;
		gint _tmp121_;
		gint _tmp122_;
		gint _jump_target_index = 0;
		_tmp118_ = catch_stack;
		_tmp119_ = _vala_iterable_ref0 (_tmp118_);
		_jump_target_list = _tmp119_;
		_tmp120_ = _jump_target_list;
		_tmp121_ = vala_collection_get_size ((ValaCollection*) _tmp120_);
		_tmp122_ = _tmp121_;
		_jump_target_size = _tmp122_;
		_jump_target_index = -1;
		while (TRUE) {
			gint _tmp123_;
			gint _tmp124_;
			ValaFlowAnalyzerJumpTarget* jump_target = NULL;
			ValaList* _tmp125_;
			gpointer _tmp126_;
			ValaFlowAnalyzerJumpTarget* _tmp164_;
			ValaBasicBlock* _tmp165_;
			ValaBasicBlock* _tmp166_;
			ValaList* _tmp167_;
			gint _tmp168_;
			gint _tmp169_;
			_jump_target_index = _jump_target_index + 1;
			_tmp123_ = _jump_target_index;
			_tmp124_ = _jump_target_size;
			if (!(_tmp123_ < _tmp124_)) {
				break;
			}
			_tmp125_ = _jump_target_list;
			_tmp126_ = vala_list_get (_tmp125_, _jump_target_index);
			jump_target = (ValaFlowAnalyzerJumpTarget*) _tmp126_;
			{
				ValaList* _prev_target_list = NULL;
				ValaList* _tmp127_;
				ValaList* _tmp128_;
				gint _prev_target_size = 0;
				ValaList* _tmp129_;
				gint _tmp130_;
				gint _tmp131_;
				gint _prev_target_index = 0;
				_tmp127_ = catch_stack;
				_tmp128_ = _vala_iterable_ref0 (_tmp127_);
				_prev_target_list = _tmp128_;
				_tmp129_ = _prev_target_list;
				_tmp130_ = vala_collection_get_size ((ValaCollection*) _tmp129_);
				_tmp131_ = _tmp130_;
				_prev_target_size = _tmp131_;
				_prev_target_index = -1;
				while (TRUE) {
					gint _tmp132_;
					gint _tmp133_;
					ValaFlowAnalyzerJumpTarget* prev_target = NULL;
					ValaList* _tmp134_;
					gpointer _tmp135_;
					ValaFlowAnalyzerJumpTarget* _tmp136_;
					ValaFlowAnalyzerJumpTarget* _tmp137_;
					ValaCodeContext* _tmp138_;
					ValaProfile _tmp139_;
					ValaProfile _tmp140_;
					_prev_target_index = _prev_target_index + 1;
					_tmp132_ = _prev_target_index;
					_tmp133_ = _prev_target_size;
					if (!(_tmp132_ < _tmp133_)) {
						break;
					}
					_tmp134_ = _prev_target_list;
					_tmp135_ = vala_list_get (_tmp134_, _prev_target_index);
					prev_target = (ValaFlowAnalyzerJumpTarget*) _tmp135_;
					_tmp136_ = prev_target;
					_tmp137_ = jump_target;
					if (_tmp136_ == _tmp137_) {
						_vala_flow_analyzer_jump_target_unref0 (prev_target);
						break;
					}
					_tmp138_ = self->priv->context;
					_tmp139_ = vala_code_context_get_profile (_tmp138_);
					_tmp140_ = _tmp139_;
					if (_tmp140_ == VALA_PROFILE_GOBJECT) {
						gboolean _tmp141_ = FALSE;
						ValaFlowAnalyzerJumpTarget* _tmp142_;
						ValaErrorDomain* _tmp143_;
						ValaErrorDomain* _tmp144_;
						ValaFlowAnalyzerJumpTarget* _tmp145_;
						ValaErrorDomain* _tmp146_;
						ValaErrorDomain* _tmp147_;
						_tmp142_ = prev_target;
						_tmp143_ = vala_flow_analyzer_jump_target_get_error_domain (_tmp142_);
						_tmp144_ = _tmp143_;
						_tmp145_ = jump_target;
						_tmp146_ = vala_flow_analyzer_jump_target_get_error_domain (_tmp145_);
						_tmp147_ = _tmp146_;
						if (_tmp144_ == _tmp147_) {
							ValaFlowAnalyzerJumpTarget* _tmp148_;
							ValaErrorCode* _tmp149_;
							ValaErrorCode* _tmp150_;
							ValaFlowAnalyzerJumpTarget* _tmp151_;
							ValaErrorCode* _tmp152_;
							ValaErrorCode* _tmp153_;
							_tmp148_ = prev_target;
							_tmp149_ = vala_flow_analyzer_jump_target_get_error_code (_tmp148_);
							_tmp150_ = _tmp149_;
							_tmp151_ = jump_target;
							_tmp152_ = vala_flow_analyzer_jump_target_get_error_code (_tmp151_);
							_tmp153_ = _tmp152_;
							_tmp141_ = _tmp150_ == _tmp153_;
						} else {
							_tmp141_ = FALSE;
						}
						if (_tmp141_) {
							ValaSourceReference* _tmp154_;
							ValaSourceReference* _tmp155_;
							_tmp154_ = vala_code_node_get_source_reference ((ValaCodeNode*) stmt);
							_tmp155_ = _tmp154_;
							vala_report_error (_tmp155_, "double catch clause of same error detected");
							vala_code_node_set_error ((ValaCodeNode*) stmt, TRUE);
							_vala_flow_analyzer_jump_target_unref0 (prev_target);
							_vala_iterable_unref0 (_prev_target_list);
							_vala_flow_analyzer_jump_target_unref0 (jump_target);
							_vala_iterable_unref0 (_jump_target_list);
							_vala_iterable_unref0 (catch_stack);
							_vala_iterable_unref0 (catch_clauses);
							_vala_basic_block_unref0 (finally_block);
							_vala_basic_block_unref0 (after_try_block);
							_vala_basic_block_unref0 (before_try_block);
							return;
						}
					} else {
						ValaFlowAnalyzerJumpTarget* _tmp156_;
						ValaClass* _tmp157_;
						ValaClass* _tmp158_;
						ValaFlowAnalyzerJumpTarget* _tmp159_;
						ValaClass* _tmp160_;
						ValaClass* _tmp161_;
						_tmp156_ = prev_target;
						_tmp157_ = vala_flow_analyzer_jump_target_get_error_class (_tmp156_);
						_tmp158_ = _tmp157_;
						_tmp159_ = jump_target;
						_tmp160_ = vala_flow_analyzer_jump_target_get_error_class (_tmp159_);
						_tmp161_ = _tmp160_;
						if (_tmp158_ == _tmp161_) {
							ValaSourceReference* _tmp162_;
							ValaSourceReference* _tmp163_;
							_tmp162_ = vala_code_node_get_source_reference ((ValaCodeNode*) stmt);
							_tmp163_ = _tmp162_;
							vala_report_error (_tmp163_, "double catch clause of same error detected");
							vala_code_node_set_error ((ValaCodeNode*) stmt, TRUE);
							_vala_flow_analyzer_jump_target_unref0 (prev_target);
							_vala_iterable_unref0 (_prev_target_list);
							_vala_flow_analyzer_jump_target_unref0 (jump_target);
							_vala_iterable_unref0 (_jump_target_list);
							_vala_iterable_unref0 (catch_stack);
							_vala_iterable_unref0 (catch_clauses);
							_vala_basic_block_unref0 (finally_block);
							_vala_basic_block_unref0 (after_try_block);
							_vala_basic_block_unref0 (before_try_block);
							return;
						}
					}
					_vala_flow_analyzer_jump_target_unref0 (prev_target);
				}
				_vala_iterable_unref0 (_prev_target_list);
			}
			_tmp164_ = jump_target;
			_tmp165_ = vala_flow_analyzer_jump_target_get_basic_block (_tmp164_);
			_tmp166_ = _tmp165_;
			_tmp167_ = vala_basic_block_get_predecessors (_tmp166_);
			_tmp168_ = vala_collection_get_size ((ValaCollection*) _tmp167_);
			_tmp169_ = _tmp168_;
			if (_tmp169_ == 0) {
				ValaFlowAnalyzerJumpTarget* _tmp170_;
				ValaCatchClause* _tmp171_;
				ValaCatchClause* _tmp172_;
				ValaSourceReference* _tmp173_;
				ValaSourceReference* _tmp174_;
				_tmp170_ = jump_target;
				_tmp171_ = vala_flow_analyzer_jump_target_get_catch_clause (_tmp170_);
				_tmp172_ = _tmp171_;
				_tmp173_ = vala_code_node_get_source_reference ((ValaCodeNode*) _tmp172_);
				_tmp174_ = _tmp173_;
				vala_report_warning (_tmp174_, "unreachable catch clause detected");
			} else {
				ValaFlowAnalyzerJumpTarget* _tmp175_;
				ValaBasicBlock* _tmp176_;
				ValaBasicBlock* _tmp177_;
				ValaBasicBlock* _tmp178_;
				ValaBasicBlock* _tmp179_;
				ValaFlowAnalyzerJumpTarget* _tmp180_;
				ValaCatchClause* _tmp181_;
				ValaCatchClause* _tmp182_;
				ValaFlowAnalyzerJumpTarget* _tmp183_;
				ValaCatchClause* _tmp184_;
				ValaCatchClause* _tmp185_;
				ValaBlock* _tmp186_;
				ValaBlock* _tmp187_;
				ValaBasicBlock* _tmp188_;
				_tmp175_ = jump_target;
				_tmp176_ = vala_flow_analyzer_jump_target_get_basic_block (_tmp175_);
				_tmp177_ = _tmp176_;
				_tmp178_ = _vala_basic_block_ref0 (_tmp177_);
				_vala_basic_block_unref0 (self->priv->current_block);
				self->priv->current_block = _tmp178_;
				_tmp179_ = self->priv->current_block;
				_tmp180_ = jump_target;
				_tmp181_ = vala_flow_analyzer_jump_target_get_catch_clause (_tmp180_);
				_tmp182_ = _tmp181_;
				vala_basic_block_add_node (_tmp179_, (ValaCodeNode*) _tmp182_);
				_tmp183_ = jump_target;
				_tmp184_ = vala_flow_analyzer_jump_target_get_catch_clause (_tmp183_);
				_tmp185_ = _tmp184_;
				_tmp186_ = vala_catch_clause_get_body (_tmp185_);
				_tmp187_ = _tmp186_;
				vala_code_node_accept ((ValaCodeNode*) _tmp187_, (ValaCodeVisitor*) self);
				_tmp188_ = self->priv->current_block;
				if (_tmp188_ != NULL) {
					ValaBasicBlock* _tmp189_;
					ValaBasicBlock* _tmp194_;
					ValaBasicBlock* _tmp195_;
					_tmp189_ = finally_block;
					if (_tmp189_ != NULL) {
						ValaBasicBlock* _tmp190_;
						ValaBasicBlock* _tmp191_;
						ValaBasicBlock* _tmp192_;
						ValaBasicBlock* _tmp193_;
						_tmp190_ = self->priv->current_block;
						_tmp191_ = finally_block;
						vala_basic_block_connect (_tmp190_, _tmp191_);
						_tmp192_ = finally_block;
						_tmp193_ = _vala_basic_block_ref0 (_tmp192_);
						_vala_basic_block_unref0 (self->priv->current_block);
						self->priv->current_block = _tmp193_;
					}
					_tmp194_ = self->priv->current_block;
					_tmp195_ = after_try_block;
					vala_basic_block_connect (_tmp194_, _tmp195_);
				}
			}
			_vala_flow_analyzer_jump_target_unref0 (jump_target);
		}
		_vala_iterable_unref0 (_jump_target_list);
	}
	_tmp196_ = finally_block;
	if (_tmp196_ != NULL) {
		ValaList* _tmp197_;
		ValaList* _tmp198_;
		gint _tmp199_;
		gint _tmp200_;
		gpointer _tmp201_;
		ValaFlowAnalyzerJumpTarget* _tmp202_;
		_tmp197_ = self->priv->jump_stack;
		_tmp198_ = self->priv->jump_stack;
		_tmp199_ = vala_collection_get_size ((ValaCollection*) _tmp198_);
		_tmp200_ = _tmp199_;
		_tmp201_ = vala_list_remove_at (_tmp197_, _tmp200_ - 1);
		_tmp202_ = (ValaFlowAnalyzerJumpTarget*) _tmp201_;
		_vala_flow_analyzer_jump_target_unref0 (_tmp202_);
	}
	_tmp203_ = after_try_block;
	_tmp204_ = vala_basic_block_get_predecessors (_tmp203_);
	_tmp205_ = vala_collection_get_size ((ValaCollection*) _tmp204_);
	_tmp206_ = _tmp205_;
	if (_tmp206_ > 0) {
		ValaBasicBlock* _tmp207_;
		ValaBasicBlock* _tmp208_;
		_tmp207_ = after_try_block;
		_tmp208_ = _vala_basic_block_ref0 (_tmp207_);
		_vala_basic_block_unref0 (self->priv->current_block);
		self->priv->current_block = _tmp208_;
	} else {
		vala_try_statement_set_after_try_block_reachable (stmt, FALSE);
		vala_flow_analyzer_mark_unreachable (self);
	}
	_vala_iterable_unref0 (catch_stack);
	_vala_iterable_unref0 (catch_clauses);
	_vala_basic_block_unref0 (finally_block);
	_vala_basic_block_unref0 (after_try_block);
	_vala_basic_block_unref0 (before_try_block);
}

static void
vala_flow_analyzer_real_visit_lock_statement (ValaCodeVisitor* base,
                                              ValaLockStatement* stmt)
{
	ValaFlowAnalyzer * self;
	self = (ValaFlowAnalyzer*) base;
	g_return_if_fail (stmt != NULL);
	if (vala_flow_analyzer_unreachable (self, (ValaCodeNode*) stmt)) {
		return;
	}
}

static void
vala_flow_analyzer_real_visit_unlock_statement (ValaCodeVisitor* base,
                                                ValaUnlockStatement* stmt)
{
	ValaFlowAnalyzer * self;
	self = (ValaFlowAnalyzer*) base;
	g_return_if_fail (stmt != NULL);
	if (vala_flow_analyzer_unreachable (self, (ValaCodeNode*) stmt)) {
		return;
	}
}

static void
vala_flow_analyzer_real_visit_expression (ValaCodeVisitor* base,
                                          ValaExpression* expr)
{
	ValaFlowAnalyzer * self;
	self = (ValaFlowAnalyzer*) base;
	g_return_if_fail (expr != NULL);
	if (!VALA_IS_LAMBDA_EXPRESSION (expr)) {
		vala_code_node_accept_children ((ValaCodeNode*) expr, (ValaCodeVisitor*) self);
	}
}

static gboolean
vala_flow_analyzer_unreachable (ValaFlowAnalyzer* self,
                                ValaCodeNode* node)
{
	ValaBasicBlock* _tmp0_;
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (node != NULL, FALSE);
	_tmp0_ = self->priv->current_block;
	if (_tmp0_ == NULL) {
		vala_code_node_set_unreachable (node, TRUE);
		if (!self->priv->unreachable_reported) {
			ValaSourceReference* _tmp1_;
			ValaSourceReference* _tmp2_;
			_tmp1_ = vala_code_node_get_source_reference (node);
			_tmp2_ = _tmp1_;
			vala_report_warning (_tmp2_, "unreachable code detected");
			self->priv->unreachable_reported = TRUE;
		}
		result = TRUE;
		return result;
	}
	result = FALSE;
	return result;
}

static void
vala_flow_analyzer_mark_unreachable (ValaFlowAnalyzer* self)
{
	g_return_if_fail (self != NULL);
	_vala_basic_block_unref0 (self->priv->current_block);
	self->priv->current_block = NULL;
	self->priv->unreachable_reported = FALSE;
}

static inline gpointer
vala_flow_analyzer_jump_target_get_instance_private (ValaFlowAnalyzerJumpTarget* self)
{
	return G_STRUCT_MEMBER_P (self, ValaFlowAnalyzerJumpTarget_private_offset);
}

static gboolean
vala_flow_analyzer_jump_target_get_is_break_target (ValaFlowAnalyzerJumpTarget* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_is_break_target;
	return result;
}

static void
vala_flow_analyzer_jump_target_set_is_break_target (ValaFlowAnalyzerJumpTarget* self,
                                                    gboolean value)
{
	g_return_if_fail (self != NULL);
	self->priv->_is_break_target = value;
}

static gboolean
vala_flow_analyzer_jump_target_get_is_continue_target (ValaFlowAnalyzerJumpTarget* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_is_continue_target;
	return result;
}

static void
vala_flow_analyzer_jump_target_set_is_continue_target (ValaFlowAnalyzerJumpTarget* self,
                                                       gboolean value)
{
	g_return_if_fail (self != NULL);
	self->priv->_is_continue_target = value;
}

static gboolean
vala_flow_analyzer_jump_target_get_is_return_target (ValaFlowAnalyzerJumpTarget* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_is_return_target;
	return result;
}

static void
vala_flow_analyzer_jump_target_set_is_return_target (ValaFlowAnalyzerJumpTarget* self,
                                                     gboolean value)
{
	g_return_if_fail (self != NULL);
	self->priv->_is_return_target = value;
}

static gboolean
vala_flow_analyzer_jump_target_get_is_exit_target (ValaFlowAnalyzerJumpTarget* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_is_exit_target;
	return result;
}

static void
vala_flow_analyzer_jump_target_set_is_exit_target (ValaFlowAnalyzerJumpTarget* self,
                                                   gboolean value)
{
	g_return_if_fail (self != NULL);
	self->priv->_is_exit_target = value;
}

static gboolean
vala_flow_analyzer_jump_target_get_is_error_target (ValaFlowAnalyzerJumpTarget* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_is_error_target;
	return result;
}

static void
vala_flow_analyzer_jump_target_set_is_error_target (ValaFlowAnalyzerJumpTarget* self,
                                                    gboolean value)
{
	g_return_if_fail (self != NULL);
	self->priv->_is_error_target = value;
}

static ValaErrorDomain*
vala_flow_analyzer_jump_target_get_error_domain (ValaFlowAnalyzerJumpTarget* self)
{
	ValaErrorDomain* result;
	ValaErrorDomain* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_error_domain;
	result = _tmp0_;
	return result;
}

static gpointer
_vala_code_node_ref0 (gpointer self)
{
	return self ? vala_code_node_ref (self) : NULL;
}

static void
vala_flow_analyzer_jump_target_set_error_domain (ValaFlowAnalyzerJumpTarget* self,
                                                 ValaErrorDomain* value)
{
	ValaErrorDomain* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = _vala_code_node_ref0 (value);
	_vala_code_node_unref0 (self->priv->_error_domain);
	self->priv->_error_domain = _tmp0_;
}

static ValaErrorCode*
vala_flow_analyzer_jump_target_get_error_code (ValaFlowAnalyzerJumpTarget* self)
{
	ValaErrorCode* result;
	ValaErrorCode* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_error_code;
	result = _tmp0_;
	return result;
}

static void
vala_flow_analyzer_jump_target_set_error_code (ValaFlowAnalyzerJumpTarget* self,
                                               ValaErrorCode* value)
{
	ValaErrorCode* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = _vala_code_node_ref0 (value);
	_vala_code_node_unref0 (self->priv->_error_code);
	self->priv->_error_code = _tmp0_;
}

static ValaClass*
vala_flow_analyzer_jump_target_get_error_class (ValaFlowAnalyzerJumpTarget* self)
{
	ValaClass* result;
	ValaClass* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_error_class;
	result = _tmp0_;
	return result;
}

static void
vala_flow_analyzer_jump_target_set_error_class (ValaFlowAnalyzerJumpTarget* self,
                                                ValaClass* value)
{
	ValaClass* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = _vala_code_node_ref0 (value);
	_vala_code_node_unref0 (self->priv->_error_class);
	self->priv->_error_class = _tmp0_;
}

static gboolean
vala_flow_analyzer_jump_target_get_is_finally_clause (ValaFlowAnalyzerJumpTarget* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_is_finally_clause;
	return result;
}

static void
vala_flow_analyzer_jump_target_set_is_finally_clause (ValaFlowAnalyzerJumpTarget* self,
                                                      gboolean value)
{
	g_return_if_fail (self != NULL);
	self->priv->_is_finally_clause = value;
}

static ValaBasicBlock*
vala_flow_analyzer_jump_target_get_basic_block (ValaFlowAnalyzerJumpTarget* self)
{
	ValaBasicBlock* result;
	ValaBasicBlock* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_basic_block;
	result = _tmp0_;
	return result;
}

static void
vala_flow_analyzer_jump_target_set_basic_block (ValaFlowAnalyzerJumpTarget* self,
                                                ValaBasicBlock* value)
{
	ValaBasicBlock* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = _vala_basic_block_ref0 (value);
	_vala_basic_block_unref0 (self->priv->_basic_block);
	self->priv->_basic_block = _tmp0_;
}

static ValaBasicBlock*
vala_flow_analyzer_jump_target_get_last_block (ValaFlowAnalyzerJumpTarget* self)
{
	ValaBasicBlock* result;
	ValaBasicBlock* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_last_block;
	result = _tmp0_;
	return result;
}

static void
vala_flow_analyzer_jump_target_set_last_block (ValaFlowAnalyzerJumpTarget* self,
                                               ValaBasicBlock* value)
{
	ValaBasicBlock* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = _vala_basic_block_ref0 (value);
	_vala_basic_block_unref0 (self->priv->_last_block);
	self->priv->_last_block = _tmp0_;
}

static ValaCatchClause*
vala_flow_analyzer_jump_target_get_catch_clause (ValaFlowAnalyzerJumpTarget* self)
{
	ValaCatchClause* result;
	ValaCatchClause* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_catch_clause;
	result = _tmp0_;
	return result;
}

static void
vala_flow_analyzer_jump_target_set_catch_clause (ValaFlowAnalyzerJumpTarget* self,
                                                 ValaCatchClause* value)
{
	ValaCatchClause* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = _vala_code_node_ref0 (value);
	_vala_code_node_unref0 (self->priv->_catch_clause);
	self->priv->_catch_clause = _tmp0_;
}

static ValaFlowAnalyzerJumpTarget*
vala_flow_analyzer_jump_target_construct_break_target (GType object_type,
                                                       ValaBasicBlock* basic_block)
{
	ValaFlowAnalyzerJumpTarget* self = NULL;
	g_return_val_if_fail (basic_block != NULL, NULL);
	self = (ValaFlowAnalyzerJumpTarget*) g_type_create_instance (object_type);
	vala_flow_analyzer_jump_target_set_basic_block (self, basic_block);
	vala_flow_analyzer_jump_target_set_is_break_target (self, TRUE);
	return self;
}

static ValaFlowAnalyzerJumpTarget*
vala_flow_analyzer_jump_target_new_break_target (ValaBasicBlock* basic_block)
{
	return vala_flow_analyzer_jump_target_construct_break_target (VALA_FLOW_ANALYZER_TYPE_JUMP_TARGET, basic_block);
}

static ValaFlowAnalyzerJumpTarget*
vala_flow_analyzer_jump_target_construct_continue_target (GType object_type,
                                                          ValaBasicBlock* basic_block)
{
	ValaFlowAnalyzerJumpTarget* self = NULL;
	g_return_val_if_fail (basic_block != NULL, NULL);
	self = (ValaFlowAnalyzerJumpTarget*) g_type_create_instance (object_type);
	vala_flow_analyzer_jump_target_set_basic_block (self, basic_block);
	vala_flow_analyzer_jump_target_set_is_continue_target (self, TRUE);
	return self;
}

static ValaFlowAnalyzerJumpTarget*
vala_flow_analyzer_jump_target_new_continue_target (ValaBasicBlock* basic_block)
{
	return vala_flow_analyzer_jump_target_construct_continue_target (VALA_FLOW_ANALYZER_TYPE_JUMP_TARGET, basic_block);
}

static ValaFlowAnalyzerJumpTarget*
vala_flow_analyzer_jump_target_construct_return_target (GType object_type,
                                                        ValaBasicBlock* basic_block)
{
	ValaFlowAnalyzerJumpTarget* self = NULL;
	g_return_val_if_fail (basic_block != NULL, NULL);
	self = (ValaFlowAnalyzerJumpTarget*) g_type_create_instance (object_type);
	vala_flow_analyzer_jump_target_set_basic_block (self, basic_block);
	vala_flow_analyzer_jump_target_set_is_return_target (self, TRUE);
	return self;
}

static ValaFlowAnalyzerJumpTarget*
vala_flow_analyzer_jump_target_new_return_target (ValaBasicBlock* basic_block)
{
	return vala_flow_analyzer_jump_target_construct_return_target (VALA_FLOW_ANALYZER_TYPE_JUMP_TARGET, basic_block);
}

static ValaFlowAnalyzerJumpTarget*
vala_flow_analyzer_jump_target_construct_exit_target (GType object_type,
                                                      ValaBasicBlock* basic_block)
{
	ValaFlowAnalyzerJumpTarget* self = NULL;
	g_return_val_if_fail (basic_block != NULL, NULL);
	self = (ValaFlowAnalyzerJumpTarget*) g_type_create_instance (object_type);
	vala_flow_analyzer_jump_target_set_basic_block (self, basic_block);
	vala_flow_analyzer_jump_target_set_is_exit_target (self, TRUE);
	return self;
}

static ValaFlowAnalyzerJumpTarget*
vala_flow_analyzer_jump_target_new_exit_target (ValaBasicBlock* basic_block)
{
	return vala_flow_analyzer_jump_target_construct_exit_target (VALA_FLOW_ANALYZER_TYPE_JUMP_TARGET, basic_block);
}

static ValaFlowAnalyzerJumpTarget*
vala_flow_analyzer_jump_target_construct_error_target (GType object_type,
                                                       ValaBasicBlock* basic_block,
                                                       ValaCatchClause* catch_clause,
                                                       ValaErrorDomain* error_domain,
                                                       ValaErrorCode* error_code,
                                                       ValaClass* error_class)
{
	ValaFlowAnalyzerJumpTarget* self = NULL;
	g_return_val_if_fail (basic_block != NULL, NULL);
	g_return_val_if_fail (catch_clause != NULL, NULL);
	self = (ValaFlowAnalyzerJumpTarget*) g_type_create_instance (object_type);
	vala_flow_analyzer_jump_target_set_basic_block (self, basic_block);
	vala_flow_analyzer_jump_target_set_catch_clause (self, catch_clause);
	vala_flow_analyzer_jump_target_set_error_domain (self, error_domain);
	vala_flow_analyzer_jump_target_set_error_code (self, error_code);
	vala_flow_analyzer_jump_target_set_error_class (self, error_class);
	vala_flow_analyzer_jump_target_set_is_error_target (self, TRUE);
	return self;
}

static ValaFlowAnalyzerJumpTarget*
vala_flow_analyzer_jump_target_new_error_target (ValaBasicBlock* basic_block,
                                                 ValaCatchClause* catch_clause,
                                                 ValaErrorDomain* error_domain,
                                                 ValaErrorCode* error_code,
                                                 ValaClass* error_class)
{
	return vala_flow_analyzer_jump_target_construct_error_target (VALA_FLOW_ANALYZER_TYPE_JUMP_TARGET, basic_block, catch_clause, error_domain, error_code, error_class);
}

static ValaFlowAnalyzerJumpTarget*
vala_flow_analyzer_jump_target_construct_any_target (GType object_type,
                                                     ValaBasicBlock* basic_block)
{
	ValaFlowAnalyzerJumpTarget* self = NULL;
	g_return_val_if_fail (basic_block != NULL, NULL);
	self = (ValaFlowAnalyzerJumpTarget*) g_type_create_instance (object_type);
	vala_flow_analyzer_jump_target_set_basic_block (self, basic_block);
	vala_flow_analyzer_jump_target_set_is_break_target (self, TRUE);
	vala_flow_analyzer_jump_target_set_is_continue_target (self, TRUE);
	vala_flow_analyzer_jump_target_set_is_return_target (self, TRUE);
	vala_flow_analyzer_jump_target_set_is_exit_target (self, TRUE);
	vala_flow_analyzer_jump_target_set_is_error_target (self, TRUE);
	return self;
}

static ValaFlowAnalyzerJumpTarget*
vala_flow_analyzer_jump_target_new_any_target (ValaBasicBlock* basic_block)
{
	return vala_flow_analyzer_jump_target_construct_any_target (VALA_FLOW_ANALYZER_TYPE_JUMP_TARGET, basic_block);
}

static ValaFlowAnalyzerJumpTarget*
vala_flow_analyzer_jump_target_construct_finally_clause (GType object_type,
                                                         ValaBasicBlock* basic_block,
                                                         ValaBasicBlock* last_block)
{
	ValaFlowAnalyzerJumpTarget* self = NULL;
	g_return_val_if_fail (basic_block != NULL, NULL);
	g_return_val_if_fail (last_block != NULL, NULL);
	self = (ValaFlowAnalyzerJumpTarget*) g_type_create_instance (object_type);
	vala_flow_analyzer_jump_target_set_basic_block (self, basic_block);
	vala_flow_analyzer_jump_target_set_last_block (self, last_block);
	vala_flow_analyzer_jump_target_set_is_finally_clause (self, TRUE);
	return self;
}

static ValaFlowAnalyzerJumpTarget*
vala_flow_analyzer_jump_target_new_finally_clause (ValaBasicBlock* basic_block,
                                                   ValaBasicBlock* last_block)
{
	return vala_flow_analyzer_jump_target_construct_finally_clause (VALA_FLOW_ANALYZER_TYPE_JUMP_TARGET, basic_block, last_block);
}

static ValaFlowAnalyzerJumpTarget*
vala_flow_analyzer_jump_target_construct (GType object_type)
{
	ValaFlowAnalyzerJumpTarget* self = NULL;
	self = (ValaFlowAnalyzerJumpTarget*) g_type_create_instance (object_type);
	return self;
}

static ValaFlowAnalyzerJumpTarget*
vala_flow_analyzer_jump_target_new (void)
{
	return vala_flow_analyzer_jump_target_construct (VALA_FLOW_ANALYZER_TYPE_JUMP_TARGET);
}

static void
vala_flow_analyzer_value_jump_target_init (GValue* value)
{
	value->data[0].v_pointer = NULL;
}

static void
vala_flow_analyzer_value_jump_target_free_value (GValue* value)
{
	if (value->data[0].v_pointer) {
		vala_flow_analyzer_jump_target_unref (value->data[0].v_pointer);
	}
}

static void
vala_flow_analyzer_value_jump_target_copy_value (const GValue* src_value,
                                                 GValue* dest_value)
{
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = vala_flow_analyzer_jump_target_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}

static gpointer
vala_flow_analyzer_value_jump_target_peek_pointer (const GValue* value)
{
	return value->data[0].v_pointer;
}

static gchar*
vala_flow_analyzer_value_jump_target_collect_value (GValue* value,
                                                    guint n_collect_values,
                                                    GTypeCValue* collect_values,
                                                    guint collect_flags)
{
	if (collect_values[0].v_pointer) {
		ValaFlowAnalyzerJumpTarget * object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = vala_flow_analyzer_jump_target_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}

static gchar*
vala_flow_analyzer_value_jump_target_lcopy_value (const GValue* value,
                                                  guint n_collect_values,
                                                  GTypeCValue* collect_values,
                                                  guint collect_flags)
{
	ValaFlowAnalyzerJumpTarget ** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = vala_flow_analyzer_jump_target_ref (value->data[0].v_pointer);
	}
	return NULL;
}

static GParamSpec*
vala_flow_analyzer_param_spec_jump_target (const gchar* name,
                                           const gchar* nick,
                                           const gchar* blurb,
                                           GType object_type,
                                           GParamFlags flags)
{
	ValaFlowAnalyzerParamSpecJumpTarget* spec;
	g_return_val_if_fail (g_type_is_a (object_type, VALA_FLOW_ANALYZER_TYPE_JUMP_TARGET), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}

static gpointer
vala_flow_analyzer_value_get_jump_target (const GValue* value)
{
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, VALA_FLOW_ANALYZER_TYPE_JUMP_TARGET), NULL);
	return value->data[0].v_pointer;
}

static void
vala_flow_analyzer_value_set_jump_target (GValue* value,
                                          gpointer v_object)
{
	ValaFlowAnalyzerJumpTarget * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, VALA_FLOW_ANALYZER_TYPE_JUMP_TARGET));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, VALA_FLOW_ANALYZER_TYPE_JUMP_TARGET));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		vala_flow_analyzer_jump_target_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		vala_flow_analyzer_jump_target_unref (old);
	}
}

static void
vala_flow_analyzer_value_take_jump_target (GValue* value,
                                           gpointer v_object)
{
	ValaFlowAnalyzerJumpTarget * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, VALA_FLOW_ANALYZER_TYPE_JUMP_TARGET));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, VALA_FLOW_ANALYZER_TYPE_JUMP_TARGET));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		vala_flow_analyzer_jump_target_unref (old);
	}
}

static void
vala_flow_analyzer_jump_target_class_init (ValaFlowAnalyzerJumpTargetClass * klass,
                                           gpointer klass_data)
{
	vala_flow_analyzer_jump_target_parent_class = g_type_class_peek_parent (klass);
	((ValaFlowAnalyzerJumpTargetClass *) klass)->finalize = vala_flow_analyzer_jump_target_finalize;
	g_type_class_adjust_private_offset (klass, &ValaFlowAnalyzerJumpTarget_private_offset);
}

static void
vala_flow_analyzer_jump_target_instance_init (ValaFlowAnalyzerJumpTarget * self,
                                              gpointer klass)
{
	self->priv = vala_flow_analyzer_jump_target_get_instance_private (self);
	self->ref_count = 1;
}

static void
vala_flow_analyzer_jump_target_finalize (ValaFlowAnalyzerJumpTarget * obj)
{
	ValaFlowAnalyzerJumpTarget * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, VALA_FLOW_ANALYZER_TYPE_JUMP_TARGET, ValaFlowAnalyzerJumpTarget);
	g_signal_handlers_destroy (self);
	_vala_code_node_unref0 (self->priv->_error_domain);
	_vala_code_node_unref0 (self->priv->_error_code);
	_vala_code_node_unref0 (self->priv->_error_class);
	_vala_basic_block_unref0 (self->priv->_basic_block);
	_vala_basic_block_unref0 (self->priv->_last_block);
	_vala_code_node_unref0 (self->priv->_catch_clause);
}

static GType
vala_flow_analyzer_jump_target_get_type_once (void)
{
	static const GTypeValueTable g_define_type_value_table = { vala_flow_analyzer_value_jump_target_init, vala_flow_analyzer_value_jump_target_free_value, vala_flow_analyzer_value_jump_target_copy_value, vala_flow_analyzer_value_jump_target_peek_pointer, "p", vala_flow_analyzer_value_jump_target_collect_value, "p", vala_flow_analyzer_value_jump_target_lcopy_value };
	static const GTypeInfo g_define_type_info = { sizeof (ValaFlowAnalyzerJumpTargetClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) vala_flow_analyzer_jump_target_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ValaFlowAnalyzerJumpTarget), 0, (GInstanceInitFunc) vala_flow_analyzer_jump_target_instance_init, &g_define_type_value_table };
	static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
	GType vala_flow_analyzer_jump_target_type_id;
	vala_flow_analyzer_jump_target_type_id = g_type_register_fundamental (g_type_fundamental_next (), "ValaFlowAnalyzerJumpTarget", &g_define_type_info, &g_define_type_fundamental_info, 0);
	ValaFlowAnalyzerJumpTarget_private_offset = g_type_add_instance_private (vala_flow_analyzer_jump_target_type_id, sizeof (ValaFlowAnalyzerJumpTargetPrivate));
	return vala_flow_analyzer_jump_target_type_id;
}

static GType
vala_flow_analyzer_jump_target_get_type (void)
{
	static volatile gsize vala_flow_analyzer_jump_target_type_id__volatile = 0;
	if (g_once_init_enter (&vala_flow_analyzer_jump_target_type_id__volatile)) {
		GType vala_flow_analyzer_jump_target_type_id;
		vala_flow_analyzer_jump_target_type_id = vala_flow_analyzer_jump_target_get_type_once ();
		g_once_init_leave (&vala_flow_analyzer_jump_target_type_id__volatile, vala_flow_analyzer_jump_target_type_id);
	}
	return vala_flow_analyzer_jump_target_type_id__volatile;
}

static gpointer
vala_flow_analyzer_jump_target_ref (gpointer instance)
{
	ValaFlowAnalyzerJumpTarget * self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}

static void
vala_flow_analyzer_jump_target_unref (gpointer instance)
{
	ValaFlowAnalyzerJumpTarget * self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		VALA_FLOW_ANALYZER_JUMP_TARGET_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}

static void
vala_flow_analyzer_class_init (ValaFlowAnalyzerClass * klass,
                               gpointer klass_data)
{
	vala_flow_analyzer_parent_class = g_type_class_peek_parent (klass);
	((ValaCodeVisitorClass *) klass)->finalize = vala_flow_analyzer_finalize;
	g_type_class_adjust_private_offset (klass, &ValaFlowAnalyzer_private_offset);
	((ValaCodeVisitorClass *) klass)->visit_source_file = (void (*) (ValaCodeVisitor*, ValaSourceFile*)) vala_flow_analyzer_real_visit_source_file;
	((ValaCodeVisitorClass *) klass)->visit_class = (void (*) (ValaCodeVisitor*, ValaClass*)) vala_flow_analyzer_real_visit_class;
	((ValaCodeVisitorClass *) klass)->visit_struct = (void (*) (ValaCodeVisitor*, ValaStruct*)) vala_flow_analyzer_real_visit_struct;
	((ValaCodeVisitorClass *) klass)->visit_interface = (void (*) (ValaCodeVisitor*, ValaInterface*)) vala_flow_analyzer_real_visit_interface;
	((ValaCodeVisitorClass *) klass)->visit_enum = (void (*) (ValaCodeVisitor*, ValaEnum*)) vala_flow_analyzer_real_visit_enum;
	((ValaCodeVisitorClass *) klass)->visit_error_domain = (void (*) (ValaCodeVisitor*, ValaErrorDomain*)) vala_flow_analyzer_real_visit_error_domain;
	((ValaCodeVisitorClass *) klass)->visit_field = (void (*) (ValaCodeVisitor*, ValaField*)) vala_flow_analyzer_real_visit_field;
	((ValaCodeVisitorClass *) klass)->visit_lambda_expression = (void (*) (ValaCodeVisitor*, ValaLambdaExpression*)) vala_flow_analyzer_real_visit_lambda_expression;
	((ValaCodeVisitorClass *) klass)->visit_method = (void (*) (ValaCodeVisitor*, ValaMethod*)) vala_flow_analyzer_real_visit_method;
	((ValaCodeVisitorClass *) klass)->visit_signal = (void (*) (ValaCodeVisitor*, ValaSignal*)) vala_flow_analyzer_real_visit_signal;
	((ValaCodeVisitorClass *) klass)->visit_creation_method = (void (*) (ValaCodeVisitor*, ValaCreationMethod*)) vala_flow_analyzer_real_visit_creation_method;
	((ValaCodeVisitorClass *) klass)->visit_property = (void (*) (ValaCodeVisitor*, ValaProperty*)) vala_flow_analyzer_real_visit_property;
	((ValaCodeVisitorClass *) klass)->visit_property_accessor = (void (*) (ValaCodeVisitor*, ValaPropertyAccessor*)) vala_flow_analyzer_real_visit_property_accessor;
	((ValaCodeVisitorClass *) klass)->visit_block = (void (*) (ValaCodeVisitor*, ValaBlock*)) vala_flow_analyzer_real_visit_block;
	((ValaCodeVisitorClass *) klass)->visit_declaration_statement = (void (*) (ValaCodeVisitor*, ValaDeclarationStatement*)) vala_flow_analyzer_real_visit_declaration_statement;
	((ValaCodeVisitorClass *) klass)->visit_local_variable = (void (*) (ValaCodeVisitor*, ValaLocalVariable*)) vala_flow_analyzer_real_visit_local_variable;
	((ValaCodeVisitorClass *) klass)->visit_expression_statement = (void (*) (ValaCodeVisitor*, ValaExpressionStatement*)) vala_flow_analyzer_real_visit_expression_statement;
	((ValaCodeVisitorClass *) klass)->visit_if_statement = (void (*) (ValaCodeVisitor*, ValaIfStatement*)) vala_flow_analyzer_real_visit_if_statement;
	((ValaCodeVisitorClass *) klass)->visit_switch_statement = (void (*) (ValaCodeVisitor*, ValaSwitchStatement*)) vala_flow_analyzer_real_visit_switch_statement;
	((ValaCodeVisitorClass *) klass)->visit_loop = (void (*) (ValaCodeVisitor*, ValaLoop*)) vala_flow_analyzer_real_visit_loop;
	((ValaCodeVisitorClass *) klass)->visit_foreach_statement = (void (*) (ValaCodeVisitor*, ValaForeachStatement*)) vala_flow_analyzer_real_visit_foreach_statement;
	((ValaCodeVisitorClass *) klass)->visit_break_statement = (void (*) (ValaCodeVisitor*, ValaBreakStatement*)) vala_flow_analyzer_real_visit_break_statement;
	((ValaCodeVisitorClass *) klass)->visit_continue_statement = (void (*) (ValaCodeVisitor*, ValaContinueStatement*)) vala_flow_analyzer_real_visit_continue_statement;
	((ValaCodeVisitorClass *) klass)->visit_return_statement = (void (*) (ValaCodeVisitor*, ValaReturnStatement*)) vala_flow_analyzer_real_visit_return_statement;
	((ValaCodeVisitorClass *) klass)->visit_yield_statement = (void (*) (ValaCodeVisitor*, ValaYieldStatement*)) vala_flow_analyzer_real_visit_yield_statement;
	((ValaCodeVisitorClass *) klass)->visit_throw_statement = (void (*) (ValaCodeVisitor*, ValaThrowStatement*)) vala_flow_analyzer_real_visit_throw_statement;
	((ValaCodeVisitorClass *) klass)->visit_try_statement = (void (*) (ValaCodeVisitor*, ValaTryStatement*)) vala_flow_analyzer_real_visit_try_statement;
	((ValaCodeVisitorClass *) klass)->visit_lock_statement = (void (*) (ValaCodeVisitor*, ValaLockStatement*)) vala_flow_analyzer_real_visit_lock_statement;
	((ValaCodeVisitorClass *) klass)->visit_unlock_statement = (void (*) (ValaCodeVisitor*, ValaUnlockStatement*)) vala_flow_analyzer_real_visit_unlock_statement;
	((ValaCodeVisitorClass *) klass)->visit_expression = (void (*) (ValaCodeVisitor*, ValaExpression*)) vala_flow_analyzer_real_visit_expression;
}

static void
vala_flow_analyzer_instance_init (ValaFlowAnalyzer * self,
                                  gpointer klass)
{
	GEqualFunc _tmp0_;
	ValaArrayList* _tmp1_;
	self->priv = vala_flow_analyzer_get_instance_private (self);
	_tmp0_ = g_direct_equal;
	_tmp1_ = vala_array_list_new (VALA_FLOW_ANALYZER_TYPE_JUMP_TARGET, (GBoxedCopyFunc) vala_flow_analyzer_jump_target_ref, (GDestroyNotify) vala_flow_analyzer_jump_target_unref, _tmp0_);
	self->priv->jump_stack = (ValaList*) _tmp1_;
}

static void
vala_flow_analyzer_finalize (ValaCodeVisitor * obj)
{
	ValaFlowAnalyzer * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, VALA_TYPE_FLOW_ANALYZER, ValaFlowAnalyzer);
	_vala_code_context_unref0 (self->priv->context);
	_vala_basic_block_unref0 (self->priv->current_block);
	_vala_iterable_unref0 (self->priv->jump_stack);
	_vala_iterable_unref0 (self->priv->all_basic_blocks);
	_vala_map_unref0 (self->priv->var_map);
	_vala_iterable_unref0 (self->priv->used_vars);
	_vala_map_unref0 (self->priv->phi_functions);
	VALA_CODE_VISITOR_CLASS (vala_flow_analyzer_parent_class)->finalize (obj);
}

/**
 * Code visitor building the control flow graph.
 */
static GType
vala_flow_analyzer_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (ValaFlowAnalyzerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) vala_flow_analyzer_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ValaFlowAnalyzer), 0, (GInstanceInitFunc) vala_flow_analyzer_instance_init, NULL };
	GType vala_flow_analyzer_type_id;
	vala_flow_analyzer_type_id = g_type_register_static (VALA_TYPE_CODE_VISITOR, "ValaFlowAnalyzer", &g_define_type_info, 0);
	ValaFlowAnalyzer_private_offset = g_type_add_instance_private (vala_flow_analyzer_type_id, sizeof (ValaFlowAnalyzerPrivate));
	return vala_flow_analyzer_type_id;
}

GType
vala_flow_analyzer_get_type (void)
{
	static volatile gsize vala_flow_analyzer_type_id__volatile = 0;
	if (g_once_init_enter (&vala_flow_analyzer_type_id__volatile)) {
		GType vala_flow_analyzer_type_id;
		vala_flow_analyzer_type_id = vala_flow_analyzer_get_type_once ();
		g_once_init_leave (&vala_flow_analyzer_type_id__volatile, vala_flow_analyzer_type_id);
	}
	return vala_flow_analyzer_type_id__volatile;
}

static void
_vala_array_destroy (gpointer array,
                     gint array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		gint i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}

static void
_vala_array_free (gpointer array,
                  gint array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}

